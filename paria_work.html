<!-- BUILD: CLEAN_v2_20250902_174148 -->
<!doctype html>
<html lang="fr">
<head>
<meta name="build" content="CLEAN_v2_20250902_174148">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>PARIA — Workbench — CLEAN_v2_20250902_174148</title>
<style>
//   PIN DOT STYLE  
.ppin{
  width:18px;height:18px;display:inline-block;vertical-align:middle;
  border:2px solid currentColor;border-radius:50%;
  background:transparent;opacity:.7;cursor:pointer;transition:opacity .2s ease;
}
.ppin[aria-pressed="true"]{ background: currentColor; opacity:1; }
#viewer .ppin{ cursor:default; pointer-events:none; opacity:.5; }

.ppin.active{ transform: rotate(-90deg); }

  :root{--line:#e6e6e6;--bg:#f7f7f8;--ink:#222}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--ink)}
  header{display:flex;align-items:center;gap:10px;padding:10px 12px;background:#fff;border-bottom:1px solid var(--line);position:sticky;top:0;z-index:10}

  //   Statuts propositions  
  .status-pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #ddd;border-radius:999px;padding:2px 8px;font-size:12px}
  .dot{width:8px;height:8px;border-radius:50%}
  .dot.pending{background:#9aa3af}
  .dot.a_preciser{background:#f59e0b}
  .dot.valide{background:#10b981}
  .dot.refuse{background:#ef4444}
  .pact{cursor:pointer}
  .pact.active{background:#222;color:#fff;border-color:#222}

  //   Grille Projecteur standalone  
  .gridProj{display:grid;grid-template-columns:280px 1fr;gap:16px}
  .gridProj.no-agenda{grid-template-columns:1fr}

  .tabs{display:flex;gap:8px;flex-wrap:wrap}
  .tabs button{background:#fff;border:1px solid var(--line);padding:8px 12px;border-radius:10px;cursor:pointer}
  .tabs button.active{background:#222;color:#fff;border-color:#222}
	button.tabbtn.active{ background:#222 !important; color:#fff !important; border-color:#222 !important; }
  .spacer{flex:1}
  .ctx{font-size:12px;opacity:.75}
  main{padding:12px;display:grid;gap:12px}
  .card{background:#fff;border:1px solid var(--line);border-radius:12px;padding:12px}
  .row{display:grid;gap:12px}
  @media(min-width:960px){ .row{grid-template-columns:1fr 1fr} }
  label{display:block;font-size:12px;color:#555;margin:6px 0 4px}
  textarea,input,select,button{font-size:14px}
  textarea{width:100%;min-height:100px}
  .actions{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .pill{padding:4px 8px;border-radius:999px;border:1px solid #ddd;background:#fafafa}
  .hide{display:none !important}
	.tab-col{display:flex;flex-direction:column}

	//   Forcer 2 colonnes “compactes” pour Journal & Projecteur, sauf très petit écran  
	#tab-analyse .row, #tab-projecteur .row {
	  grid-template-columns: minmax(280px, 1fr) minmax(380px, 1fr);
	}
	@media (max-width: 720px){
	  #tab-analyse .row, #tab-projecteur .row { grid-template-columns: 1fr; }
	}

  //   Projecteur (onglet)  
	#projAgenda{
	  border:1px solid #ddd;border-radius:10px;padding:10px;
	  max-height:70vh;overflow:auto;position:sticky;top:8px
	}
	#projCard{
	  border:1px solid #ddd;border-radius:10px;padding:16px;
	  min-height:60vh;max-height:70vh;overflow:auto;background:#fff
	}

  //   Projecteur standalone  
  .full{max-width:1200px;margin:0 auto;padding:16px}

	//   container 2 colonnes pour le projecteur inline  
	#projectorInline{
	  display: grid;
	  grid-template-columns: 320px 1fr;
	  gap: 12px;
	  align-items: start;
	}
	
	//   colonne gauche (agenda) sticky et scroll indépendante  
	.proj-left{
	  position: sticky;
	  top: 8px;
	  max-height: calc(100vh - 160px);
	  overflow: auto;
	  border-right: 1px solid #eee;
	  padding-right: 8px;
	}
	
	//   colonne droite scroll indépendante  
	.proj-right{
	  max-height: calc(100vh - 160px);
	  overflow: auto;
	}
	#projAgendaList a, #p_agenda a {
  display: block;
  white-space: normal;
  overflow: visible;
  text-overflow: clip;
  word-break: break-word;
	word-wrap: anywhere;		
}
	

//   --- Journal layout tweaks ---  
#tab-analyse .row{
  display:grid;
  grid-template-columns: minmax(320px,1fr) 1fr;
  gap:16px;
  align-items:start;
}
#tab-analyse .row > .card:not(#journalDetailCard){ grid-column: 1; } //   left stack  
#tab-analyse #journalDetailCard{ grid-column: 2; }                  //   right panel  

//   Hide Journal export/import buttons  
#tab-analyse button[id*="Export"], #tab-analyse button[id*="Import"]{ display:none !important; }
</style>
</head>
<body>

<header>
  <div class="tabs" id="tabbar">
    <button class="tabbtn active" data-tab="reglages">Réglages</button>
    <button class="tabbtn" data-tab="capture">Charter</button>
    <button class="tabbtn" data-tab="analyse">Journal</button> 
		<button class="tabbtn" data-tab="cards">Cards</button>
    <button class="tabbtn" data-tab="projecteur">Projecteur</button>
    <button class="tabbtn" data-tab="scenarios">Scénarios</button>
    <button id="btnStartSess">Démarrer séance</button>
    <button id="btnCopyGuest" disabled>Copier lien invité</button>
    <button id="btnPauseSess" disabled>Pause</button>
    <button id="btnRotateGuest" disabled>Changer lien</button>
    <button id="btnEndSess" disabled>Terminer</button>
    <span id="liveState" class="pill">offline</span>
  </div>
  <div class="spacer"></div>
  <div class="ctx">Service:
    <select id="serviceKey">
      <option>Direction</option><option>RH</option><option selected>Compta</option>
      <option>IT</option><option>Marketing</option><option>Ventes</option>
    </select>
    &nbsp;|&nbsp; Work ID: <span id="workIdHdr">—</span>
 		&nbsp;·&nbsp; Card #<span id="cardHdr">—</span>

  </div>
</header>

<main>
  <!-- RÉGLAGES -->
  <section id="tab-reglages" class="card">
    <h3>Réglages / Persistance</h3>
    <div class="row">
      <div class="card">
        <h4>Google Apps Script (proxy)</h4>
        <label>URL publique (cette page)</label>
        <input id="public_base" placeholder="https://jeromejouve-lab.github.io/paria-tool/paria_work.html">
        <label>DEPLOY URL</label>
        <input id="GAS_URL" placeholder="https://script.google.com/macros/s/AKfycb.../exec" style="width:380px">
		<div class="row" style="margin-top:6px">
		  <label for="PROXY_SECRET" style="min-width:100px;display:inline-block">Proxy secret</label>
		  <input id="PROXY_SECRET" type="password" placeholder="ex: my_secret" style="width:100px">
		</div>
        <div class="actions">
          <button id="btnSaveCfg">Sauver</button>
          <button id="btnTestProxy">Tester</button>
          <span id="proxyState" class="pill">—</span>
        </div>
        <small>Le proxy gère : <code>route=analyze|save|load|echo</code>.</small>
      </div>

      <div class="card">
        <h4>Work ID (Client · Service · Date)</h4>
        <label>Client</label><input id="workClient" placeholder="ACME">
        <label>Date</label><input id="workDate" type="date">
        <div class="actions">
          <button id="btnBindWork">Lier ce Work ID</button>
					<div class="row" style="margin-top:6px">
					  <label for="restoreAt" style="min-width:160px;display:inline-block">Date à restaurer</label>
					  <input id="restoreAt" placeholder="jj/mm/aaaa HH:mm ou jj/mm/aaaa" style="width:220px">
					  <button id="btnGitPropose" title="Proposer un snapshot Git">Proposer</button>
					  <button id="btnGitRestore" title="Restaurer le snapshot proposé">Restaurer</button>
					  <span id="gitState" class="pill">—</span>
					</div>
          <span id="workBindState" class="pill">—</span>
        </div>
        <small>Le Work ID est mémorisé et visible en haut. Il permet de ré-ouvrir la même séance.</small>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h4>Charger / Sauver (Apps Script)</h4>
        <div class="actions">
          <button id="btnLoad">Charger depuis Google</button>
          <button id="btnSave">Sauver vers Google</button>
          <span id="gsState" class="pill">—</span>
        </div>
      </div>

      <div class="card">
        <h4>GitHub (versionning)</h4>
        <label>Owner</label><input id="gh_owner" placeholder="jeromejouve-lab">
        <label>Repo</label><input id="gh_repo" placeholder="paria-audits">
        <label>Branch</label><input id="gh_branch" placeholder="main">
        <label>Base path</label><input id="gh_base" placeholder="clients">
        <label>Token PAT</label><input id="gh_token" type="password" placeholder="ghp_...">
        <label>Message de commit</label><input id="gh_msg" placeholder="feat: audit Compta 2025-08-28">
        <div class="actions">
          <button id="btnSaveGh">Sauver</button>
          <span id="ghState" class="pill">—</span>
        </div>
        <small>Le snapshot pousse l’état du service courant + un Markdown de synthèse.</small>
      </div>
    </div>

    <div class="row">
      <div class="card">
        <h4>État local</h4>
		<div class="actions" style="gap:8px;align-items:center;margin-bottom:8px">
		  <button id="btnDump">Voir JSON</button>
		  <button id="btnClear">Réinitialiser local</button>
		</div>
		<pre id="dump"
		     style="white-space:pre-wrap;background:#fafafa;border:1px solid #eee;border-radius:8px;padding:8px;
		            min-height:240px;max-height:70vh;overflow:auto;resize:vertical">—</pre>
      </div>
    </div>
  </section>

  <!-- CAPTURE -->
  <section id="tab-capture" class="card hide">
    <div class="row">
      <div class="card">
        <h3>Service Charter</h3>
        <label>Objectifs</label><textarea id="ch_obj"></textarea>
        <label>Contexte & contraintes</label><textarea id="ch_ctx"></textarea>
        <label>Périmètre</label><textarea id="ch_scope"></textarea>
        <label>Contraintes strictes</label><textarea id="ch_hard"></textarea>
        <label>Douleurs (top 3)</label><textarea id="ch_pains"></textarea>
        <label>KPI</label><textarea id="ch_kpi"></textarea>
        <label>Outils</label><textarea id="ch_tools"></textarea>
        <label>Rôles & charge</label><textarea id="ch_roles"></textarea>
        <label>Budget & fenêtre</label><textarea id="ch_budget"></textarea>
        <div class="actions">
          <button id="btnCharterToState">Sauver dans l’état</button>
          <button id="btnCharterFromState">Charger de l’état</button>
          <span id="charterState" class="pill">—</span>
        </div>
      </div>

      <div class="card">
        <h3>Note → Analyse IA</h3>
        <div class="actions">
          <button id="btnMic">🎙️ Dicter</button>
          <span id="micStatus" class="pill">—</span>
        </div>
        <textarea id="note" placeholder="Parle ou tape ici…"></textarea>
        <div class="actions">
          <button id="btnAnalyze">Analyser (AI)</button>
          <span id="aiState" class="pill">—</span>
        </div>
        <h4>Résultat</h4>
        <pre id="analysis" style="white-space:pre-wrap;background:#fafafa;border:1px solid #eee;border-radius:8px;padding:8px;max-height:260px;overflow:auto">—</pre>
      </div>
    </div>
  </section>

  <!-- ANALYSE / DÉCISIONS -->
  <section id="tab-analyse" class="card hide tab-col" style="min-height:calc(100vh - 160px)">
    <div class="row">
      <div class="card">
        <h3>Dernier item (réformulation & PARIA)</h3>
        <pre id="lastItem" style="white-space:pre-wrap;background:#fafafa;border:1px solid #eee;border-radius:8px;padding:8px;min-height:240px;max-height:calc(100vh - 280px);overflow:auto;resize:vertical">—</pre>
        <div class="actions">
          <button data-status="valide"  class="decide">Valider</button>
          <button data-status="a_preciser" class="decide">À préciser</button>
          <button data-status="refuse" class="decide">Refuser</button>
          <span id="decState" class="pill">—</span>
        </div>
      </div>

      <div class="card">
        <h3>Décisions (journal)</h3>
        <div style="max-height:calc(100vh - 280px);overflow:auto">
				  <div id="decisions"></div>
				</div>
        <div class="actions" style="margin-top:8px">
          <button id="btnExportMd">Exporter Markdown</button>
          <button id="btnExportClientHtml">Exporter HTML client</button>
          <button id="btnImportClientJson">Importer réponses client (JSON)</button>
          <input id="clientJsonFile" type="file" accept="application/json" style="display:none">
          <span id="expState" class="pill">—</span>
        </div>
      </div>
			<div class="card" id="journalDetailCard">
			  <h4 style="margin:0 0 8px 0">Contenu sélectionné</h4>
			  <pre id="journalDetail"
			       style="white-space:pre-wrap;border:1px solid #ddd;border-radius:8px;padding:8px;
			              min-height:160px;max-height:calc(100vh - 320px);overflow:auto">—</pre>
			</div>
    </div>
  </section>

  <!-- PROJECTEUR (dans la page) -->
  <section id="tab-projecteur" class="card hide">
    <div class="actions" style="justify-content:space-between">
      <div><strong>Projecteur (prévisualisation)</strong></div>
      <div class="actions"><button id="btnOpenProjector">Ouvrir le Projecteur (nouvel onglet)</button></div>
    </div>

    <div class="row">
      <aside id="projAgenda" class="card">
        <h4>Agenda (simplifié)</h4>
        <ol id="projAgendaList"></ol>
      </aside>

      <div id="projCard" class="card">
        <em>Analyse un item dans “Capture” pour l’afficher ici, ou ouvre le Projecteur.</em>
      </div>
    </div>
  </section>

  <!-- SCÉNARIOS -->
  <section id="tab-scenarios" class="card hide">
    <div class="actions">
      <button id="btnForkScenario">Dupliquer depuis l’état courant</button>
      <button id="btnPromoteScenario">Promouvoir comme version de travail</button>
    </div>
    <div id="scList" style="margin-top:10px"></div>
	<div id="scWork" class="card" style="margin-top:10px"></div>
  </section>
</main>

<script>
//   ====== CONFIG ======  
const MODEL   = 'gpt-4o-mini';
const GAS_KEY = 'paria_gas_url';
const DB_KEY  = 'paria_db';
const WORK_KEY= 'paria_work_id'; // "ACME|Compta|2025-08-28"
window.DEBUG = true; // passe à false pour couper
const D = function () {
  if (!window.DEBUG) return;
  console.log.apply(console, arguments);
};

//   ====== GitHub cfg ======  
const GH_OWNER='paria_gh_owner', GH_REPO='paria_gh_repo', GH_BRANCH='paria_gh_branch',
      GH_BASE='paria_gh_base', GH_TOKEN='paria_gh_token';
const GH_API = 'https://api.github.com';
const DEFAULT_GAS_URL = ''; // optionnel: mets ici ton URL Apps Script pour préremplir au 1er chargement
const PROXY_SECRET_KEY = 'paria_proxy_secret';

	

function gasUrl(){ return (localStorage.getItem(GAS_KEY)||'').trim(); }
function setGasUrl(u){ localStorage.setItem(GAS_KEY,u.trim()); }
function proxySecret(){ return (localStorage.getItem(PROXY_SECRET_KEY)||'').trim(); }
function setProxySecret(v){ localStorage.setItem(PROXY_SECRET_KEY, (v||'').trim()); }

//   ====== ÉTAT LOCAL ======  
let db = { services:{} }; // services[key]={ charter:{}, items:[], decisions:[], scenarios:[] }
function currentService(){ return document.getElementById('serviceKey').value; }
function svc(){
  const k=currentService();
  if(!db.services[k]) db.services[k]={ charter:{}, items:[], decisions:[], scenarios:[] };
  return db.services[k];
}

function shrinkStateJson(raw, limit=60){
  try {
    const S = JSON.parse(raw);
    if (Array.isArray(S.decisions)) {
      // garde uniquement les 60 dernières décisions (snapshots intacts)
      if (S.decisions.length > limit) {
        S.decisions = S.decisions.slice(-limit);
      }
    }
    return JSON.stringify(S);
  } catch { return raw; }
}

function trimAllClientDBs(limit=60){
  const keys = Object.keys(localStorage);
  for (const k of keys){
    if (k === 'paria_db' || k.startsWith('paria_db_')){
      try {
        const raw = localStorage.getItem(k);
        if (!raw) continue;
        const trimmed = shrinkStateJson(raw, limit);
        if (trimmed && trimmed.length <= raw.length){
          localStorage.setItem(k, trimmed);
        }
      } catch(_) { /* ignore */ }
    }
  }
}

function bootQuotaGuard(){
  try {
    // test minimal d’écriture ; si ça plante, on purge toutes les bases
    localStorage.setItem('__paria_quota_probe', '1');
    localStorage.removeItem('__paria_quota_probe');
  } catch {
    trimAllClientDBs(60);
  }
}

function loadDB(){
  const cid = getClientId();
  let raw = localStorage.getItem(storageKey(cid));

  if (!raw){
    const legacy = localStorage.getItem('paria_db');
    if (legacy){
      try{
        let payload = legacy;
        try{
          const obj = JSON.parse(legacy);
          const k = (typeof currentService==='function' ? currentService() : null) || 'Compta';
          const svcOnly = obj?.services && obj.services[k] ? obj.services[k] : obj;
          if (svcOnly && Array.isArray(svcOnly.decisions) && svcOnly.decisions.length > 60){
            svcOnly.decisions = svcOnly.decisions.slice(-60);
          }
          payload = JSON.stringify({
            charter:   svcOnly.charter||{},
            items:     Array.isArray(svcOnly.items) ? svcOnly.items : [],
            scenarios: Array.isArray(svcOnly.scenarios) ? svcOnly.scenarios : [],
            decisions: Array.isArray(svcOnly.decisions) ? svcOnly.decisions : [],
            meta: { client_id: cid, rev: 0, updated_ts: Date.now() }
          });
        }catch(_){ /* non-JSON : on garde legacy brute */ }

        // ÉCRITURE + suppression plus sûre (voir point 1)
        try {
          localStorage.setItem(storageKey(cid), payload);
          localStorage.removeItem('paria_db');
          raw = payload;
        } catch(eSet){
          localStorage.removeItem('paria_db');
          localStorage.setItem(storageKey(cid), payload);
          raw = payload;
        }

      }catch(e){
        console.warn('Migration paria_db -> namespaced échouée', e);
        try {
          const obj = JSON.parse(legacy);
          const k = (typeof currentService==='function' ? currentService() : null) || 'Compta';
          const svcOnly = obj?.services && obj.services[k] ? obj.services[k] : obj;
          const minimal = JSON.stringify({
            charter:   svcOnly.charter || {},
            items:     Array.isArray(svcOnly.items) ? svcOnly.items : [],
            scenarios: Array.isArray(svcOnly.scenarios) ? svcOnly.scenarios : [],
            decisions: [], // vide pour passer le quota
            meta: { client_id: cid, rev: 0, updated_ts: Date.now() }
          });
          // même séquence “écrire puis supprimer” si possible
          try {
            localStorage.setItem(storageKey(cid), minimal);
            localStorage.removeItem('paria_db');
            raw = minimal;
          } catch(eMin){
            localStorage.removeItem('paria_db');
            localStorage.setItem(storageKey(cid), minimal);
            raw = minimal;
          }
        } catch(e2){
          // ultime fallback : session seulement
          raw = legacy;
        }
      }
    }
  }

  // Chargement défensif + recapping
  let S;
  try {
    S = raw ? JSON.parse(raw) : { decisions:[], items:[], scenarios:[], charter:{}, meta:{ client_id:cid, rev:0, updated_ts: Date.now() } };
  } catch {
    S = { decisions:[], items:[], scenarios:[], charter:{}, meta:{ client_id:cid, rev:0, updated_ts: Date.now() } };
  }
  if (Array.isArray(S.decisions) && S.decisions.length > 60){
    S.decisions = S.decisions.slice(-60);
  }

  ensureMeta(S);
  window.__svc = S;
  addClient(cid);
  return S;
}

function dedupeJournal(list){
  if (!Array.isArray(list)) return [];
  const seen = new Set();
  const out  = [];
  for (const d of list){
    const sig = [
      d.type||d.action||d.status||'log',
      d.item?.id||d.refs?.card_id||d.refs?.scenario_id||'',
      d.note||'',
      // on arrondit le timestamp pour absorber les double-binds dans la même seconde
      Math.floor((d.ts||0)/1000)
    ].join('|');
    if (!seen.has(sig)){ seen.add(sig); out.push(d); }
  }
  return out;
}
	
function capJournal(S, limit=60){
  S.decisions = dedupeJournal(S.decisions||[]);
  if (S.decisions.length > limit) S.decisions = S.decisions.slice(-limit);
}

function saveDB(){
  const S = (typeof svc==='function') ? svc() : window.__svc;
  if (!S) return;
  ensureMeta(S);
  capJournal(S, 60); // <-- AJOUT clé
  try{
    localStorage.setItem(storageKey(getClientId()), JSON.stringify(S));
  }catch(e1){
    try{
      if (typeof emergencyTrim==='function') emergencyTrim(S);
      capJournal(S, 60); // on recape après trim
      localStorage.setItem(storageKey(getClientId()), JSON.stringify(S));
    }catch(e2){
      try{
        // fallback: purge plus dur du journal si tu as une fonction maison
        if (typeof purgeJournalHard==='function') purgeJournalHard();
        capJournal(S, 40);
        localStorage.setItem(storageKey(getClientId()), JSON.stringify(S));
      }catch(e3){
        console.error('saveDB: quota insurmontable', e3);
        alert("Stockage local saturé. Exportez/épurez puis réessayez.");
      }
    }
  }
}
	
let __touch_t, __sync_t;
function touch(){
  const S = (typeof svc==='function') ? svc() : window.__svc;
  if (S) bumpRev(S);       // incrémente la révision à chaque mutation
  if (__touch_t) clearTimeout(__touch_t);
  __touch_t = setTimeout(()=>{ try{ saveDB(); scheduleSync('touch'); }catch(e){} }, 120);
}

const SYNC_DEBOUNCE_MS = 800;
const SYNC_MIN_GAP_MS = 5000;
let __last_sync = 0;
function scheduleSync(reason){
  const { auto_sync } = getProxyConfig();
  if (!auto_sync) return;
  if (!navigator.onLine) return;
  const nowt = now();
  if (nowt - __last_sync < SYNC_MIN_GAP_MS){
    if (__sync_t) clearTimeout(__sync_t);
    __sync_t = setTimeout(()=>doAutoSync(reason), SYNC_DEBOUNCE_MS);
    return;
  }
  if (__sync_t) clearTimeout(__sync_t);
  __sync_t = setTimeout(()=>doAutoSync(reason), SYNC_DEBOUNCE_MS);
}

async function pullRemote(){
  const S = (typeof svc==='function') ? svc() : window.__svc;
  ensureMeta(S);
  const localRev = S.meta.rev|0;

  const r = await proxyCall('load_client_state', {
    client_id: getClientId(),
    want:'state'
  }); // Attendu côté Apps Script: { state: {...}, ok:true } ou { ok:true, state:null }

  const remote = r && r.state ? r.state : null;
  if (!remote) return { changed:false, reason:'no-remote' };

  // Sécurité: si le proxy ne renvoie pas meta, on le crée
  remote.meta = remote.meta || { client_id:getClientId(), rev:0, updated_ts: now() };
  const remoteRev = remote.meta.rev|0;

  if (remoteRev > localRev){
    window.__svc = remote;
    localStorage.setItem(storageKey(getClientId()), JSON.stringify(remote));
    if (typeof renderAll==='function') renderAll();
    else {
      if (typeof renderDecisions==='function') renderDecisions();
      if (typeof renderCardsTab==='function') renderCardsTab();
      if (typeof renderProjectorInline==='function') renderProjectorInline();
    }
    return { changed:true, reason:'remote-newer' };
  }
  return { changed:false, reason:'local-up-to-date-or-newer' };
}

async function pushRemote(){
  const S = (typeof svc==='function') ? svc() : window.__svc;
  if (!S) return { pushed:false, reason:'no-state' };
  ensureMeta(S);
  const payload = JSON.parse(JSON.stringify(S)); // clone

  const r = await proxyCall('save_client_state', {
    client_id: getClientId(),
    state: payload
  }); // Attendu: { ok:true, rev: <echo or server rev> }
  return { pushed: !!(r && r.ok), rev: r?.rev };
}

async function doAutoSync(reason){
  try{
    const cfg = getProxyConfig();
    if (!cfg.auto_sync || !cfg.url || !cfg.secret) return;
    __last_sync = now();

    // 1) Pull en premier (autoload après sélection client)
    const pr = await pullRemote();

    // 2) Si local > remote (ex. offline modifs), push
    const S = (typeof svc==='function') ? svc() : window.__svc;
    const localRev = S?.meta?.rev|0;

    // On re-demande la remote (simple, pas de merge complexe ici)
    if (pr.reason!=='remote-newer'){
      await pushRemote();
    }
  }catch(e){
    console.warn('doAutoSync error', e);
  }
}
	
// Au boot, charge local puis tente un pull remote en non-bloquant
(function bootAutoLoad(){

	// Au boot, garde 60 si quota serré
	bootQuotaGuard();
  loadDB();
  // rendu initial
  if (typeof renderAll==='function') renderAll();
  else {
    if (typeof renderDecisions==='function') renderDecisions();
    if (typeof renderCardsTab==='function') renderCardsTab();
    if (typeof renderProjectorInline==='function') renderProjectorInline();
  }
	
  // pull remote (et push si local plus récent) en tâche de fond
  scheduleSync('boot');
})();

// Re-sync quand on revient online
window.addEventListener('online', ()=> scheduleSync('online'));

// Basculer de client = sauvegarder l'état courant, charger l'autre, puis sync auto
async function switchClient(id){
  // 1) save courant
  try{
    if (window.__svc){
      localStorage.setItem(storageKey(getClientId()), JSON.stringify(window.__svc));
    }
  }catch(e){ console.warn('switchClient/saveCurrent', e); }

  // 2) set & load
  addClient(id);
  const key = storageKey(id);
  const raw = localStorage.getItem(key);
  window.__svc = raw ? JSON.parse(raw) : { decisions:[], items:[], scenarios:[], charter:{}, meta:{ client_id:id, rev:0, updated_ts: now() } };

  // 3) rendu
  if (typeof renderAll==='function') renderAll();
  else {
    if (typeof renderDecisions==='function') renderDecisions();
    if (typeof renderCardsTab==='function') renderCardsTab();
    if (typeof renderProjectorInline==='function') renderProjectorInline();
  }

  // 4) autoload depuis proxy + éventuel push
  scheduleSync('switchClient');
}

//   ====== ONGLETING ======  
const tabs = ['reglages','capture','analyse','projecteur','scenarios', 'cards'];
	
function showTab(id){
  const tabs = ['reglages','capture','analyse','projecteur','scenarios','cards'];
  tabs.forEach(t=>{
    const el = document.getElementById('tab-'+t);
    if (!el) return;
    el.classList.toggle('hide', t!==id);
    if (el.style) el.style.removeProperty('display'); // nettoie tout display inline résiduel
  });

  // Active = sur le vrai conteneur d’onglets (#tabbar)
  const bar = document.getElementById('tabbar');
  if (bar){
    bar.querySelector('.tabbtn.active')?.classList.remove('active');
    bar.querySelector(`.tabbtn[data-tab="${id}"]`)?.classList.add('active');
  }

  // Hooks d’affichage
  if(id==='cards'      && typeof renderCardsTab==='function')       renderCardsTab();
  if(id==='analyse'    && typeof renderDecisions==='function')      renderDecisions();
  if(id==='projecteur' && typeof renderProjectorInline==='function')renderProjectorInline();
  if(id==='scenarios'  && typeof renderScList==='function')         renderScList();
}
	
// Ne pas booter l'UI complète en mode Projecteur, mais binder les onglets quand même
const __IS_PROJECTOR = new URL(location.href).searchParams.get('projecteur') === '1';

// délégation unique sur #tabbar (survit aux re-rendus)
document.getElementById('tabbar')?.addEventListener('click', (e)=>{
  const btn = e.target.closest('.tabbtn');
  if (!btn) return;
  showTab(btn.dataset.tab);
});

if (!__IS_PROJECTOR) {
  loadDB();
  showTab('reglages');
}

//   ====== WORK ID ======  
function currentWorkId(){
  const c = (document.getElementById('workClient').value||'').trim() || 'CLIENT';
  const s = currentService();
  const d = (document.getElementById('workDate').value||'').trim() || new Date().toISOString().slice(0,10);
  return `${c}|${s}|${d}`;
}
function parseWorkId(){
  const wid = localStorage.getItem(WORK_KEY)||'CLIENT|'+currentService()+'|'+new Date().toISOString().slice(0,10);
  const [client, service, date] = wid.split('|');
  return {client, service, date};
}
	
function bindWork(){
  const id = currentWorkId(); // "CLIENT|Service|YYYY-MM-DD"
  localStorage.setItem(WORK_KEY, id);
  document.getElementById('workIdHdr').textContent = id;

  // --- NEW: fixe aussi le client courant pour la base namespacée + sync ---
  const [client, service] = id.split('|');
  if (client) setClientId(client.trim());
  if (service && typeof selectService==='function') selectService(service.trim());

  document.getElementById('workBindState').textContent = 'lié ✔';
  // Option: déclenche un pull/push non bloquant
  if (typeof scheduleSync==='function') scheduleSync('bindWork');
}

//   ====== SESSION SYNC ======  
let sess = { id:null, operator_token:null, guest_token:null, last_seq:0, paused:false };
let poller = null;
function publicBase(){ return (localStorage.getItem('paria_public_base')||'').trim(); }

function selectService(k){ if(document.getElementById('serviceKey')) document.getElementById('serviceKey').value = k; }
const svcSel = document.getElementById('serviceKey');
if (svcSel){
  svcSel.onchange = ()=>{
    // persist current service selection if you already do so:
    // localStorage.setItem('paria_service', svcSel.value);
    if (typeof hydrateCharter==='function') hydrateCharter();
    if (typeof renderDecisions==='function') renderDecisions();
    if (typeof renderProjectorInline==='function') renderProjectorInline();
    if (typeof refreshDump==='function') refreshDump();
  };
}	

async function gasPost(route, payload){
  const u = gasUrl(); if(!u) throw new Error('Proxy non configuré');
  const body = Object.assign(
	  {},
	  { route: route, secret: proxySecret() },
	  (payload && typeof payload === 'object') ? payload : {}
	);

  const r = await fetch(u,{ method:'POST', headers:{'Content-Type':'text/plain'}, body: JSON.stringify(body) });
  const j = await r.json(); if(!j.ok) throw new Error(j.error||route+' ko'); return j;
}
async function gasGet(route, qs){
  const u = new URL(gasUrl());
  u.searchParams.set('route', route);
  u.searchParams.set('secret', proxySecret());
  Object.entries(qs||{}).forEach(([k,v])=>u.searchParams.set(k, String(v)));
  const r = await fetch(u.toString());
  const j = await r.json(); if(!j.ok) throw new Error(j.error||route+' ko'); return j;
}
	
// ===== Parse FR -> ISO (jj/mm/aaaa [HH:mm]) =====
function parseFrAt(input, widDateISO){
  const s = (input||'').trim();
  if (!s) return widDateISO; // fallback: date du WID
  // ISO direct ?
  if (/^\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2})?$/.test(s)) return s.replace(' ','T');
  // FR jj/mm/aaaa HH:mm ?
  const m = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})(?:\s+(\d{1,2}):(\d{2}))?$/);
  if (!m) return widDateISO;
  const dd = String(m[1]).padStart(2,'0');
  const MM = String(m[2]).padStart(2,'0');
  const yyyy = m[3];
  const hh = String(m[4]||'00').padStart(2,'0');
  const mm = String(m[5]||'00').padStart(2,'0');
  return m[4] ? `${yyyy}-${MM}-${dd}T${hh}:${mm}` : `${yyyy}-${MM}-${dd}`;
}

// ===== Git API (via Apps Script) =====
async function gitFind(atISO){
  const wid = localStorage.getItem('paria_work_id') || currentWorkId();
  // Spec: route=git_find ?work_id=...&at=YYYY-MM-DD[THH:mm]
  // Retour attendu: { ok:true, hit:{ ts, sha?, json_path }, prev_ts?, next_ts? }
  const j = await gasGet('git_find', { work_id: wid, at: atISO }); // :contentReference[oaicite:3]{index=3}
  if (!j || !j.ok) return null;
  return j; // on renvoie l’objet complet (hit + éventuels prev_ts/next_ts si dispo)
}

async function gitLoad(hit){
  const wid = localStorage.getItem('paria_work_id') || currentWorkId();
  const svcKey = (wid.split('|')[1]||'').trim() || currentService();
  const qs = { work_id: wid };
  if (hit.sha) qs.sha = hit.sha;
  if (hit.json_path) qs.json_path = hit.json_path;
  // Spec: route=git_load ?work_id=...&sha=... | &json_path=...
  const j = await gasGet('git_load', qs); // :contentReference[oaicite:4]{index=4}
  if (!j || !j.ok || !j.state) throw new Error('git_load: état vide');

  // Normalisation comme pour btnLoad Google
	const data = j.state.charter ? j.state : Object.assign({charter:{},items:[],decisions:[],scenarios:[]}, (j.state||{}));

  // Range dans le service courant et persist local
  window.db = window.db || { services:{} };
  db.services = db.services || {};
  db.services[svcKey] = data;
  if (typeof saveDB==='function') saveDB();                 // :contentReference[oaicite:5]{index=5}
  if (typeof selectService==='function') selectService(svcKey); // :contentReference[oaicite:6]{index=6}
  if (typeof renderDecisions==='function') renderDecisions();   // :contentReference[oaicite:7]{index=7}
}

// ===== Boutons UI =====
document.getElementById('btnGitPropose')?.addEventListener('click', async ()=>{
  try{
    const wid = localStorage.getItem('paria_work_id') || currentWorkId();
    const { date } = parseWorkId();                        // :contentReference[oaicite:8]{index=8}
    const atISO = parseFrAt(document.getElementById('restoreAt')?.value||'', date);
    const j = await gitFind(atISO);
    const el = document.getElementById('gitState');
    if (!j || !j.hit){ if(el) el.textContent='Aucun snapshot'; return; }

    // On mémorise la proposition
    window.__git_hit = j.hit;

    // Affichage "restauré/proposé" + voisins si fournis par l’API
    const t = new Date(j.hit.ts||Date.now()).toLocaleString();
    let aux = '';
    if ('prev_ts' in j && j.prev_ts) aux += ` | précédent: ${new Date(j.prev_ts).toLocaleTimeString()}`;
    if ('next_ts' in j && j.next_ts) aux += ` | suivant: ${new Date(j.next_ts).toLocaleTimeString()}`;
    if (el) el.textContent = `Proposé: ${t}${aux}`;
  }catch(e){
    const el = document.getElementById('gitState'); if (el) el.textContent='Erreur propose';
  }
});

document.getElementById('btnGitRestore')?.addEventListener('click', async ()=>{
  try{
    const el = document.getElementById('gitState');
    const hit = window.__git_hit;
    if (!hit){ if(el) el.textContent='Aucune proposition'; return; }
    if (el) el.textContent='Chargement Git…';
    await gitLoad(hit);
    if (el){
      const t = new Date(hit.ts||Date.now()).toLocaleString();
      el.textContent = `Restauré: ${t}`; // voisins déjà affichés lors de "Proposer"
    }
  }catch(e){ const el=document.getElementById('gitState'); if(el) el.textContent='Erreur chargement'; }
});

btnStartSess.onclick = async ()=>{
	await saveCloudNow(); // baseline cloud IMMEDIATE avant la séance
  const wid = localStorage.getItem('paria_work_id')||'';
  const j = await gasPost('session_start', {work_id: wid, moderation: false});
  sess.id=j.session_id; sess.operator_token=j.operator_token; sess.guest_token=j.guest_token; sess.last_seq=0; sess.paused=false;
  liveState.textContent='live'; btnCopyGuest.disabled=btnPauseSess.disabled=btnRotateGuest.disabled=btnEndSess.disabled=false;

	// -- construire et mémoriser le lien invité (propre) --
  const base = publicBase() || location.href.split('?')[0];
  const u = new URL(base);
  u.searchParams.set('projecteur','1');
  u.searchParams.set('session', sess.id);
  u.searchParams.set('role','guest');
  u.searchParams.set('token', sess.guest_token);

  const prox = gasUrl();
  if (prox) {
    try { const pu = new URL(prox); pu.search = ''; u.searchParams.set('prox', pu.toString()); }
    catch { u.searchParams.set('prox', prox.split('?')[0]); }
  }
  if (wid) u.searchParams.set('wid', wid);
  const ps  = proxySecret();
  if (ps)  u.searchParams.set('ps', ps);

  window._guest_url = u.toString();      // <- lien prêt à copier
  btnCopyGuest.disabled = false;         // activé
  btnCopyGuest.style.background = '#f59e0b'; // orange
  btnCopyGuest.style.color = '#fff';

  startPoll();
};
btnEndSess.onclick = async ()=>{
  if(!sess.id) return;
  await gasPost('session_end', {session_id: sess.id});
  stopPoll(); sess={id:null,operator_token:null,guest_token:null,last_seq:0,paused:false};
  liveState.textContent='offline'; btnCopyGuest.disabled=btnPauseSess.disabled=btnRotateGuest.disabled=btnEndSess.disabled=true;
};
btnPauseSess.onclick = async ()=>{
  if(!sess.id) return;
  const j = await gasPost('session_pause', {session_id: sess.id, paused: !sess.paused});
  sess.paused = j.paused; liveState.textContent = sess.paused? 'paused' : 'live';
};
btnRotateGuest.onclick = async ()=>{
  if(!sess.id) return;
  const j = await gasPost('session_rotate', {session_id: sess.id});
  sess.guest_token = j.guest_token;
  alert('Nouveau lien invité généré.');
};
btnCopyGuest.onclick = async ()=>{
  if (!window._guest_url) return;
  try {
    await navigator.clipboard.writeText(window._guest_url);
  } catch {
    // fallback silencieux (pas d'alert)
    const ta = document.createElement('textarea');
    ta.value = window._guest_url;
    ta.style.position='fixed'; ta.style.opacity='0';
    document.body.appendChild(ta); ta.select();
    document.execCommand('copy'); document.body.removeChild(ta);
  }
};

const dumpEl = document.getElementById('dump');

function refreshDump(){
  try {
    const s = svc(); // ton état courant (service sélectionné)
    dumpEl.textContent = JSON.stringify(s || {}, null, 2);
  } catch(e) {
    dumpEl.textContent = 'Erreur JSON: ' + e.message;
  }
}

btnDump.onclick = () => {
  const raw = localStorage.getItem('paria_db');
  const obj = raw ? JSON.parse(raw) : (window.db || {});
  const el  = document.getElementById('dump');
  if (!el) { alert('Élément <pre id="dump"> introuvable.'); return; }
  el.textContent = JSON.stringify(obj, null, 2) || '—';
  // au cas où c’est masqué par un wrapper :
  el.parentElement?.classList?.remove('hide');
  el.style.display = 'block';
};

function startPoll(){
  stopPoll();
  poller = setInterval(async ()=>{
    if(!sess.id) return;
    try{
      const j = await gasGet('events_since', {session_id: sess.id, token: sess.operator_token, after: sess.last_seq});
      sess.paused = j.paused; liveState.textContent = sess.paused? 'paused' : 'live';
      (j.events||[]).forEach(ev=>{ sess.last_seq=Math.max(sess.last_seq, ev.seq||0); applyEvent(ev); });
    }catch(e){}
  }, 1500);
}
function stopPoll(){ if(poller){ clearInterval(poller); poller=null; } }

//   Applique un event entrant invited/operator -> sur l’état  
function applyEvent(ev){
  const e = ev.event||{};
  const s = svc();
  if(e.type==='prop_decision'){
    const it = (s.items||[]).find(x=>x.id===e.card_id); if(!it) return;
    const p = (it.propositions||[]).find(x=>x.pid===e.pid); if(!p) return;
    p.decision = p.decision || {status:'a_preciser', comment:''};
    if(e.status)  p.decision.status  = e.status;
    if(e.comment!==undefined) p.decision.comment = e.comment;
    it.pipeline = recomputePipelineForItem(it);
    touch();
    // si la card affichée est celle-ci, re-render
  }
  if(e.type==='comment'){ // commentaire simple (crée un fil de discussions basique)
    const it = (s.items||[]).find(x=>x.id===e.card_id); if(!it) return;
    (it.comments||(it.comments=[])).push({ts:ev.ts, who: ev.role, pid: e.pid, text:e.text});
    touch();
  }
  if(e.type==='pin_card'){
    // Sélectionner la carte côté opérateur et rafraîchir le projecteur inline
    try{
      window._projSel = e.card_id;
      if (typeof renderProjectorInline === 'function') renderProjectorInline();
    }catch(_){}
  }
	
  // plus tard: sim_create (Sx) -> ajouter à it.propositions[i].sims
  touch();
}

// Paramètres de rotation du Journal
const MAX_DECISIONS       = 400;  // taille max du journal
const KEEP_SNAP_FULL      = 60;   // nb d'events conservés avec snapshot complet (restaurables)
const KEEP_SNAP_META      = 140;  // nb d'events suivants gardés en "meta" (restauration non garantie)
                                   // le reste: sans snap (juste trace)

function pickCardMeta(c){
  if (!c) return null;
  return { id: c.id, title: c.title, status: c.status, service: c.service, ts: c.ts||c.created_ts };
}
function pickScenarioMeta(s){
  if (!s) return null;
  return { id: s.id, title: s.title, date: s.date||s.when, state: s.state, ts: s.ts };
}
function pickCharterMeta(ch){
  if (!ch) return null;
  return { title: ch.title, version: ch.version, ts: ch.ts };
}

function emergencyTrim(db){
  if (!db) return false;
  let changed = false;
  const ds = Array.isArray(db.decisions) ? db.decisions : [];
  const L  = ds.length;

  // 1) Si trop d’entrées, on dégrade progressivement les snapshots
  if (L > KEEP_SNAP_FULL + KEEP_SNAP_META){
    // Anciennes entrées (les plus vieilles) => on supprime les snaps
    for (let i = 0; i < L - (KEEP_SNAP_FULL + KEEP_SNAP_META); i++){
      if (ds[i]?.snap){ delete ds[i].snap; changed = true; }
    }
    // Entrées "métadonnées"
    for (let i = Math.max(0, L - (KEEP_SNAP_FULL + KEEP_SNAP_META)); i < L - KEEP_SNAP_FULL; i++){
      const ent = ds[i];
      if (!ent) continue;
      if (!ent.snap) continue;
      if (ent.snap.card){ ent.snap.card = pickCardMeta(ent.snap.card); changed = true; }
      if (ent.snap.scenario){ ent.snap.scenario = pickScenarioMeta(ent.snap.scenario); changed = true; }
      if (ent.snap.charter){ ent.snap.charter = pickCharterMeta(ent.snap.charter); changed = true; }
    }
  }

  // 2) Taille maximale absolue du journal
  if (ds.length > MAX_DECISIONS){
    ds.splice(0, ds.length - MAX_DECISIONS);
    db.decisions = ds;
    changed = true;
  }

  return changed;
}
	
//   Helpers pour pousser un event quand TOI tu agis  
async function pushDecision(card_id, pid, status, comment){
  if(!sess.id) return; // si pas de séance, pas d’event (local only)
  try{
    await gasPost('event_push', {session_id: sess.id, token: sess.operator_token, role:'operator', event:{type:'prop_decision', card_id, pid, status, comment}});
  }catch(e){}
}
async function pushComment(card_id, pid, text){
  if(!sess.id) return;
  try{
    await gasPost('event_push', {session_id: sess.id, token: sess.operator_token, role:'operator', event:{type:'comment', card_id, pid, text}});
  }catch(e){}
}
// --- pin: épingler un item dans la séance (et le viewer)
async function pushPin(card_id){
  if(!sess.id) return;
  try{
    await gasPost('event_push', {
      session_id: sess.id,
      token: sess.operator_token,
      role: 'operator',
      event: { type: 'pin_card', service: currentService(), card_id }
    });
  }catch(_){}
}

let _saveTimer=null, _lastSaveTs=0;
function autosaveCloud(){
  if(_saveTimer) clearTimeout(_saveTimer);
  _saveTimer = setTimeout(async ()=>{
    try{
      const wid = localStorage.getItem('paria_work_id')||'';
      const service = currentService();
      const state = svc();
      await gasPost('save', { work_id: wid, client_id: parseWorkId().client, state });
      _lastSaveTs = Date.now();
      if (gsState) gsState.textContent = 'Sauvé ✔ ' + new Date(_lastSaveTs).toLocaleTimeString();
    }catch(e){}
  }, 1200);
}
async function saveCloudNow(){
  const wid = localStorage.getItem('paria_work_id')||currentWorkId();
  const state = svc();
  await gasPost('save', { work_id: wid, client_id: parseWorkId().client, state });
}

//   ====== SNAPSHOT GIT AUTO (10 min) ======  
let _gitTimer = null, _lastGitTs = 0;
async function snapshotGitAuto(reason='auto-10min'){
  try{
    const wid = localStorage.getItem(WORK_KEY)||'';
    if(!wid) return;
    const {service, date} = parseWorkId();
    const s = svc();
    const state_json = JSON.stringify(s,null,2);
    const md = makeMarkdown(service, s);
    const message = (gh_msg?.value || `snapshot(${reason}): ${service} ${date}`);
    const {client} = parseWorkId();
		await gasPost('git_snapshot', { work_id: wid, client_id: client, service, date, state_json, md, message });

    _lastGitTs = Date.now();
    if (ghState) ghState.textContent = 'Auto ✔ ' + new Date(_lastGitTs).toLocaleTimeString();
  }catch(e){
    if (ghState) ghState.textContent = 'Auto: en attente';
    // on n’interrompt pas la séance : on retentera au prochain tick
  }
}
function startGitTimer(){
  if(_gitTimer) clearInterval(_gitTimer);
  _gitTimer = setInterval(()=> snapshotGitAuto('auto-10min'), 10*60*1000); // 10 min
}
startGitTimer();
 
//   ====== BOOT RÉGLAGES ======  
(function bootCfg(){
  document.getElementById('GAS_URL').value = gasUrl();
	document.getElementById('public_base').value = publicBase();
  const today = new Date().toISOString().slice(0,10);
  document.getElementById('workDate').value = today;
  const wid = localStorage.getItem(WORK_KEY)||'—';
  document.getElementById('workIdHdr').textContent = wid;
	// NEW: si un Work ID existe, on pré-renseigne le client et on positionne le clientId
	if (wid && wid !== '—') {
	  const {client, service} = parseWorkId();
	  if (client) { document.getElementById('workClient').value = client; setClientId(client); }
	  if (service && typeof selectService==='function') selectService(service);
	}

	document.getElementById('PROXY_SECRET').value = proxySecret();

  // GH cfg
  gh_owner.value  = localStorage.getItem(GH_OWNER)||'';
  gh_repo.value   = localStorage.getItem(GH_REPO)||'';
  gh_branch.value = localStorage.getItem(GH_BRANCH)||'main';
  gh_base.value   = localStorage.getItem(GH_BASE)||'clients';
  gh_token.value  = localStorage.getItem(GH_TOKEN)||'';
  gh_msg.value    = gh_msg.value || `feat: audit ${currentService()} ${today}`;
})();
	
btnSaveCfg.onclick = ()=>{
  setGasUrl(document.getElementById('GAS_URL').value);
  localStorage.setItem('paria_public_base', document.getElementById('public_base').value.trim());
  localStorage.setItem(PROXY_SECRET_KEY, document.getElementById('PROXY_SECRET').value.trim());
  alert('Réglages sauvegardés.');
};

btnTestProxy.onclick = async ()=>{
  const u = gasUrl(); if(!u) return alert('Renseigne le DEPLOY URL.');
  try{
    const pong = await fetch(gasUrl()+`?route=ping&secret=${encodeURIComponent(proxySecret())}`); // <-- ton PROXY_SECRET
    const j = await pong.json();
    proxyState.textContent = j.ok ? 'OK ✔' : 'Erreur';
  }catch(e){
    proxyState.textContent = 'Erreur';
  }
};

btnBindWork.onclick = bindWork;

//   ====== LOAD / SAVE (Apps Script) ======  
btnLoad.onclick = async ()=>{
  const u = gasUrl(); if(!u) return alert('Proxy non configuré.');
  const wid = localStorage.getItem(WORK_KEY) || currentWorkId();      // ex: ACME|Compta|2025-08-30
  const svcKey = (wid.split('|')[1] || '').trim() || currentService();// <- clé service depuis WID
  gsState.textContent = 'Chargement…';
  try{
    const clientId = (parseWorkId().client || 'CLIENT');
		const r = await fetch(`${u}?route=load&secret=${encodeURIComponent(proxySecret())}&work_id=${encodeURIComponent(wid)}&client_id=${encodeURIComponent(clientId)}`);
    const j = await r.json();
    if(j.ok && j.data){
      // normalise si besoin (au cas où le JSON n’a pas la structure attendue)
      const data = (j && j.data && j.data.charter)
		  ? j.data
		  : Object.assign(
		      { charter:{}, items:[], decisions:[], scenarios:[] },
		      (j && j.data) ? j.data : {}
		    );
      db.services = db.services || {};
      db.services[svcKey] = data;     // <- range au bon endroit
      saveDB();
      // option: bascule l’UI sur ce service
      if (typeof selectService === 'function') selectService(svcKey);
      gsState.textContent='Chargé ✔';
    } else if(j.ok && !j.data){
      gsState.textContent='Aucune donnée';
    } else {
      gsState.textContent='Erreur'; alert('LOAD: '+(j.error||'inconnu'));
    }
  }catch(e){ gsState.textContent='Erreur'; alert('LOAD exception: '+e.message); }
};


btnSave.onclick = async ()=>{
  const u=gasUrl(); if(!u) return alert('Proxy non configuré.');
  const wid = localStorage.getItem(WORK_KEY)||currentWorkId();
  const key = currentService();
  const state = db.services[key] || {charter:{},items:[],decisions:[],scenarios:[]};
  try{
    const clientId = (parseWorkId().client || 'CLIENT');
		const body = { route:'save', secret: proxySecret(), work_id: wid, client_id: clientId, state };
		const r = await fetch(u,{ method:'POST', headers:{'Content-Type':'text/plain'}, body: JSON.stringify(body) });
    const j = await r.json();
    gsState.textContent = j.ok ? 'Sauvé ✔' : 'Erreur';
  }catch(e){ gsState.textContent='Erreur'; alert(e.message); }
};

//   ====== DUMP / CLEAR ======  
btnClear.onclick = () => {
  if (!confirm('Effacer l’état local (tous clients) ?')) return;
  // remove legacy
  localStorage.removeItem('paria_db');
  // remove all namespaced
  Object.keys(localStorage).forEach(k=>{
    if (k.startsWith('paria_db_')) localStorage.removeItem(k);
  });
  // reboot état en RAM
  if (typeof loadDB === 'function') loadDB();
  const el = document.getElementById('dump');
  if (el) el.textContent = '—';
  alert('Réinitialisé.');
};

//   ====== CHARTER ======  
function hydrateCharter(){
  const ch = (svc().charter||{});
  ch_obj.value = ch.objectifs||''; ch_ctx.value=ch.contexte||''; ch_scope.value=ch.perimetre||'';
  ch_hard.value = ch.contraintes||''; ch_pains.value=ch.douleurs||''; ch_kpi.value=ch.kpis||'';
  ch_tools.value=ch.outils||''; ch_roles.value=ch.roles||''; ch_budget.value=ch.budget||'';
  charterState.textContent='Chargé ✔';
}
btnCharterFromState.onclick = hydrateCharter;
btnCharterToState.onclick = ()=>{
  const s=svc();
  s.charter = {
    objectifs: ch_obj.value.trim(), contexte: ch_ctx.value.trim(), perimetre: ch_scope.value.trim(),
    contraintes: ch_hard.value.trim(), douleurs: ch_pains.value.trim(), kpis: ch_kpi.value.trim(),
    outils: ch_tools.value.trim(), roles: ch_roles.value.trim(), budget: ch_budget.value.trim()
  };
  touch(); charterState.textContent='Sauvé ✔';
};

//   ====== DICTÉE (anti-duplication) ======  
(function setupMic(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR){ micStatus.textContent='(non supportée)'; return; }
  const rec=new SR(); rec.lang='fr-FR'; rec.continuous=true; rec.interimResults=false;
  let on=false;
  btnMic.onclick=()=>{
    if(!on){ rec.start(); on=true; micStatus.textContent='Écoute…'; btnMic.textContent='■ Stop'; }
    else   { rec.stop();  on=false; micStatus.textContent='—';       btnMic.textContent='🎙️ Dicter'; }
  };
  rec.onresult=(e)=>{
    for(let i=e.resultIndex;i<e.results.length;i++){
      const res=e.results[i]; if(res.isFinal){
        const txt=res[0].transcript.trim();
        if(!note.value.trim().endsWith(txt)) note.value=(note.value+' '+txt).trim();
      }
    }
  };
  rec.onend=()=>{ if(on) rec.start(); else { micStatus.textContent='—'; btnMic.textContent='🎙️ Dicter'; } };
})();

//   ====== ANALYSE (Apps Script -> OpenAI) ======  
btnAnalyze.onclick = async ()=>{
  const u=gasUrl(); if(!u) return alert('Proxy non configuré.');
  const s=svc();
  const noteEl = document.getElementById('note');
	const noteText = noteEl ? noteEl.value : '';
	const payload = { route:'analyze', secret: proxySecret(), model: MODEL, service_key: currentService(), charter: s.charter, note: noteText };
	console.log('[analyze] note len=', noteText.length, 'sample=', noteText.slice(0,80));

  aiState.textContent='Analyse…';
  try{
    const r=await fetch(u,{method:'POST',headers:{'Content-Type':'text/plain'},body:JSON.stringify(payload)});
    const j=await r.json();
    if(!j.ok) throw new Error(j.error||'analyse KO');
    const item=j.data;

    // normalisation
    item.id = item.id || ('I'+((s.items?.length||0)+1));
    item.title = item.title || (item.reformulation || 'Sujet à préciser');
    (item.propositions||[]).forEach((p,i)=>{
      p.pid = p.pid || ('P'+(i+1));
      p.decision = p.decision || { status:'a_preciser', comment:'' };
    });
    item.pipeline = item.pipeline || 'pret_projecteur';
    item.priority = item.priority || 'P2';

  	// si le titre renvoyé est court, préfère la reformulation plus complète
		if ((item.reformulation||'').length > (item.title||'').length) {
  		item.title = item.reformulation;
		}

    s.items.push(item);
    touch();
    analysis.textContent = JSON.stringify(item,null,2);
    aiState.textContent='OK ✔';
    touch();
  }catch(e){
    aiState.textContent='Erreur';
    alert('Analyse échouée: '+e.message);
  }
};

function openScenario(sid){
  const s = svc(); const sc=(s.scenarios||[]).find(x=>x.id===sid); 
  const el=document.getElementById('scWork'); if(!el){return;}
  if(!sc){ el.innerHTML='<em>Aucun scénario sélectionné.</em>'; return; }
  const snap = sc.snapshot || { items:[], decisions:[] };
  const it = (snap.items||[]).find(x=>String(x.id)===String(s._lastCard || (s.items||[])[(s.items||[]).length-1]?.id)) || snap.items[0];
  if(!it){ el.innerHTML='<em>Scénario vide.</em>'; return; }

	el.innerHTML = `
	  <div style="display:flex;gap:8px;margin-bottom:8px">
	    <button id="btnScInsert">Insérer sims sélectionnées (${htmlEscape(sc.id)})</button>
	    <button id="btnScPromote">Promouvoir ${htmlEscape(sc.id)}</button>
	  </div>
	  ${renderCardCommon(
	    (sc.snapshot?.items||[]).find(x=>String(x.id)===String((svc()._lastCard)||((svc().items||[]).slice(-1)[0]?.id))) 
	    || (sc.snapshot?.items||[])[0] || {propositions:[]}
	  )}
	`;

  // handlers card dans le snapshot (édition dans le snapshot)
  attachCardHandlers(
    el,
    ()=>snap,
    (S)=>{ sc.snapshot = S; saveDB(); },
    ()=>{ openScenario(sid); }
  );

  // actions spécifiques
  document.getElementById('btnScInsert').onclick = ()=>{
    const ref = svc(); // modèle projecteur
    // pour chaque proposition pickée du snapshot, on l’insère/maj dans la card de ref
    (snap.items||[]).forEach(si=>{
      const ti = (ref.items||[]).find(x=>String(x.id)===String(si.id)); if(!ti) return;
      (si.propositions||[]).forEach(sp=>{
        (sp.sims||[]).filter(sm=>sm.picked).forEach(sm=>{
          const tp=(ti.propositions||[]).find(pp=>String(pp.pid)===String(sp.pid)); if(!tp) return;
          tp.sims = Array.isArray(tp.sims) ? tp.sims : [];
					tp.sims.push(
					  Object.assign(
					    {},
					    sm || {},
					    { origin: (sm && sm.origin) || 'IA', who: 'scenario', scenario: sc.id, id: tp.sims.length + 1 }
					  )
					);
        });
      });
    });
    alert('Simulations insérées depuis '+sc.id);
  };

  document.getElementById('btnScPromote').onclick = ()=>{
    const ref = svc();
    ref.items = JSON.parse(JSON.stringify(snap.items||[]));
    ref.decisions = JSON.parse(JSON.stringify(snap.decisions||[]));
    alert('Scénario '+sc.id+' promu sur la carte de référence.');
  };
}
	
function recomputePipelineForItem(it){
  const statuses = (it.propositions||[]).map(p=> (p.decision?.status)||'a_preciser');
  const hasAny = statuses.some(s => s==='valide' || s==='refuse');
  const allFinal = statuses.length>0 && statuses.every(s => s==='valide' || s==='refuse');
  if (allFinal) return 'bouclee';
  if (hasAny)   return 'en_validation';
  return 'pret_projecteur';
}

// Demande de stockage persistant (si supporté)
(async function tryPersistStorage(){
  try {
    if (navigator.storage && navigator.storage.persist) {
      await navigator.storage.persist();
    }
  } catch(e){}
})();

async function runSim(item, prop, comment){
  const u = gasUrl(); if(!u) return alert('Proxy non configuré.');
  const s = svc();
  const payload = {
	  route:'analyze', secret: proxySecret(), model:MODEL,
	  service_key: currentService(),
	  charter: s.charter,
	  note: comment || (item.reformulation||'')
	};

  try{
    const r = await fetch(u,{method:'POST',headers:{'Content-Type':'text/plain'},body:JSON.stringify(payload)});
    const j = await r.json(); if(!j.ok) throw new Error(j.error||'analyse KO');
    const now = Date.now();
    const sid = 'S'+(((prop.sims||[]).length||0)+1);
    const sim = {
      id: sid, origin:'IA', ts: now,
      comment_source: comment||'',
      impact: { cout:'≈', delai:'≈', risque:'≈' }, // tu peux raffiner avec le retour
      paria: j.data?.paria || {},
      note: j.data?.reformulation || 'Simulation générée'
    };
    (prop.sims||(prop.sims=[])).push(sim);
    item.pipeline = recomputePipelineForItem(item);
    touch(); // autosave local + Drive
  }catch(e){
    alert('Simulation KO: '+e.message);
  }
}
// ================== PROXY / GIT SYNC ==================
function getSettings(){
  // Adapter si tu as déjà un objet settings global
  try{ return JSON.parse(localStorage.getItem('paria_settings')||'{}'); }catch(e){ return {}; }
}
function setSettings(x){
  localStorage.setItem('paria_settings', JSON.stringify(x||{}));
}
function getProxyConfig(){
  const st = getSettings();
  return {
    url: st.proxy_url,           // ex: "https://script.google.com/macros/s/XXX/exec"
    secret: st.proxy_secret,     // PROXY_SECRET
    repo: st.repo || "paria-audits", // optionnel, si utile côté Apps Script
    auto_sync: st.auto_sync !== false, // true par défaut
  };
}
function now(){ return Date.now(); }

// ================== CLIENT NAMESPACE ==================
function getClientId(){ return localStorage.getItem('paria_current_client') || 'default'; }
function setClientId(id){ localStorage.setItem('paria_current_client', String(id||'default')); }
function storageKey(clientId){ return `paria_db_${String(clientId||getClientId())}`; }

function listClients(){
  try{ const L = JSON.parse(localStorage.getItem('paria_clients')||'[]'); return Array.isArray(L)?L:[]; }catch(e){ return []; }
}
function addClient(id){
  const cid = String(id||'default');
  const L = listClients(); if (!L.includes(cid)){ L.push(cid); localStorage.setItem('paria_clients', JSON.stringify(L)); }
  setClientId(cid);
}

// ================== REVISION & META ==================
function ensureMeta(S){
  S.meta = S.meta || {};
  S.meta.client_id = getClientId();
  S.meta.updated_ts = S.meta.updated_ts || now();
  S.meta.rev = typeof S.meta.rev==='number' ? S.meta.rev : 0;
  return S.meta;
}
function bumpRev(S){
  const m = ensureMeta(S);
  m.rev = (m.rev|0) + 1;
  m.updated_ts = now();
  return m.rev;
}

// ================== FETCH WRAPPER ==================
async function proxyCall(action, payload){
  const cfg = getProxyConfig();
  if (!cfg.url || !cfg.secret) throw new Error('Proxy non configuré (proxy_url / proxy_secret manquants).');

  const body = {
    action,
    secret: cfg.secret,
    client_id: getClientId(),
    repo: cfg.repo,
    payload,
  };
  const r = await fetch(cfg.url, {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(body),
  });
  if (!r.ok) throw new Error(`Proxy HTTP ${r.status}`);
  const json = await r.json().catch(()=> ({}));
  if (json.error) throw new Error(json.error);
  return json;
}

//   ====== DÉCISIONS ======  
function renderLastItem(){
  const s=svc();
  const it = (s.items||[])[(s.items||[]).length-1];
  if(!it){ lastItem.textContent='—'; return; }
  lastItem.textContent = JSON.stringify({
    id: it.id, title: it.title||it.reformulation||'', paria: it.paria||{}, propositions: it.propositions||[], questions: it.questions||[]
  },null,2);
}

document.querySelectorAll('.decide').forEach(b=>{
  b.onclick = ()=>{
    const s=svc(); const it=(s.items||[])[(s.items||[]).length-1]; if(!it) return;
    (s.decisions||(s.decisions=[])).push({
      ts: Date.now(),
      status: b.dataset.status,
      item: { id: it.id, reformulation: it.reformulation||it.title||'' }
    });
    touch();
    renderDecisions();
    decState.textContent='Noté ✔';
  };
});

function renderDecisions(){
  const S = svc();
  const el = document.getElementById('decisions');
  if (!el) return;

  const list = S.decisions || [];
  if (!list.length){
    el.innerHTML = '<em>Aucune entrée.</em>';
    const det0 = document.getElementById('journalDetail');
    if (det0) det0.textContent = '';
    return;
  }

	el.innerHTML = list.map(d=>{
	  const act = d.action || d.type || d.status || 'log';
	  const when = new Date(d.ts||Date.now()).toLocaleString();
	  const sid = d.refs?.sid || '';
	  const cid = d.refs?.card_id || '';
	  // label lisible (préférence: titre snapshot)
	  const label = d.snap?.title
	             || d.note
	             || (d.item && d.item.reformulation)
	             || sid || cid || '';
	  let actionHtml = '';
	  if (act==='scenario_deleted' && sid){
	    actionHtml = ` <button class="ev-restore-scenario" data-sid="${sid}">Restaurer</button>`;
	  }
		
		// ... dans renderDecisions() / list.map(d=>{ ... })
		if (act==='charter_saved'){
		  actionHtml = ` <button class="ev-restore-charter" data-eid="${d.id}">Restaurer</button>`;
		}
	  if (act==='card_deleted' && cid){
	    actionHtml = ` <button class="ev-restore-card" data-cid="${cid}">Restaurer</button>`;
	  }
	  return `<div class="pill"
	               data-eid="${d.id}"
	               data-act="${act}"
	               data-sid="${sid}"
	               data-card="${cid}">
	            ${when} — <b>${act}</b> — ${label}${actionHtml}
	          </div>`;
	}).reverse().join('');

  // panneau détail (colonne droite)
  let det = document.getElementById('journalDetail');
  if(!det){
    det = document.createElement('pre');
    det.id = 'journalDetail';
    det.style.whiteSpace = 'pre-wrap';
    det.style.border = '1px solid #ddd';
    det.style.borderRadius = '8px';
    det.style.padding = '8px';
    det.style.marginTop = '8px';
    el.parentNode && el.parentNode.appendChild(det);
  } else {
    det.textContent = '';
  }
}


// Alias legacy (certaines zones appellent encore renderJournal)
window.renderJournal = window.renderDecisions;

// --- JOURNAL: rebinder à l'ouverture + au besoin ---
(function(){
  // 1) Forcer un render du Journal quand on affiche l'onglet
  if (typeof window.showTab === 'function') {
    const _origShowTab = window.showTab;
    window.showTab = function(id){
      _origShowTab(id);
      if (id === 'analyse' && typeof window.renderDecisions === 'function') {
        window.renderDecisions();
      }
      if (id === 'cards' && typeof window.renderCardsTab === 'function') {
        window.renderCardsTab();
      }
    };
  }

  // 2) Option UX: masquer le panneau "Dernier item" dans le Journal
  // (on garde le HTML mais on le cache pour ne garder QUE la liste + le détail)
  const journal = document.getElementById('tab-analyse');
  if (journal) {
    const firstCard = journal.querySelector('.card h3');
    if (firstCard && /Dernier item/i.test(firstCard.textContent||'')) {
      firstCard.closest('.card').style.display = 'none';
    }
  }
})();

//   ====== EXPORTS ======  
btnExportMd.onclick=()=>{
  const key=currentService(); const s=svc();
  const md = makeMarkdown(key,s);
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([md],{type:'text/markdown'}));
  a.download=`audit_${key}_${new Date().toISOString().slice(0,10)}.md`; a.click();
  expState.textContent='Exporté ✔';
};

function makeMarkdown(key,s){
  const L=[]; 
  L.push(`# Audit ${key} — PARIA`,'','## Service Charter');
  for (const [k,v] of Object.entries(s.charter||{})){
    L.push(`- **${k}**: ${v||'-'}`);
  }
  L.push('','## Analyses');
  (s.items||[]).forEach((it,i)=>{
    L.push(`### Item #${i+1} (${it.id})`);
    if (it.reformulation) L.push(`Reformulation: ${it.reformulation}`);
    const b = it.paria||{};
    for (const k of ['problemes','ameliorations','reconfigurations','integration_ia','actions']){
      if (Array.isArray(b[k]) && b[k].length){
        L.push(`- **${k}**:`);
        b[k].forEach(x=>L.push(`  - ${x}`));
      }
    }
    if (Array.isArray(it.questions) && it.questions.length){
      L.push(`- **Questions**:`);
      it.questions.forEach(q=>L.push(`  - ${q}`));
    }
    if (Array.isArray(it.propositions) && it.propositions.length){
      L.push(`- **Propositions**:`);
      it.propositions.forEach(p=>{
        const cout = (p && p.indicateurs && p.indicateurs.cout) ?? '-';
        const cx   = (p && p.indicateurs && p.indicateurs.complexite) ?? '-';
        L.push(`  - ${p?.pid||''} — ${p?.label||''} [${cout}/${cx}]`);
      });
    }
    L.push('');
  });
  L.push('## Décisions');
  (s.decisions||[]).forEach(d=>{
    const when = new Date(d.ts||Date.now()).toLocaleString();
    const status = d.status || d.type || '';
    const txt = (d.item && d.item.reformulation) || d.note || '';
    L.push(`- ${when} — **${status}** — ${txt}`);
  });
  return L.join('\n');
}

//   ====== Export HTML client + Import JSON ======  
btnExportClientHtml.onclick = ()=>{
  const s = svc();
  const pack = { service: currentService(), charter: s.charter, items: s.items };
  const html = makeClientHtml(pack);
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([html],{type:'text/html'}));
  a.download = `form_client_${currentService()}_${new Date().toISOString().slice(0,10)}.html`;
  a.click();
};

btnImportClientJson.onclick = ()=> clientJsonFile.click();
clientJsonFile.onchange = async (e)=>{
  const f=e.target.files?.[0]; if(!f) return;
  let obj; try{ obj=JSON.parse(await f.text()); }catch{ return alert('JSON invalide'); }
  const s=svc(); let n=0;
  (obj?.responses||[]).forEach(r=>{
    const it = (s.items||[]).find(x=>x.id===r.card_id); if(!it) return;
    const p  = (it.propositions||[]).find(y=>y.pid===r.pid); if(!p) return;
    p.decision = { status:r.decision, comment:r.comment||'', source:'client', ts: Date.now(), import_file: (f?.name||'') };
    it.pipeline = recomputePipelineForItem(it);
    n++;
   	(s.decisions||(s.decisions=[])).push({ 
		  ts: Date.now(), type:'client_import', status:r.decision,
		  item:{ id:it.id, reformulation: it.reformulation||it.title||'' },
		  note:`${r.pid} ${r.decision}${r.comment? ' ('+r.comment+')':''} · file:${f?.name||''}`
		});
  });
  touch(); 
  renderDecisions();
  alert(`Réponses client intégrées (${n}).`);
};

// Génère une page autonome que le client peut remplir (puis Télécharger JSON)
// Génère une page autonome que le client peut remplir (puis Télécharger JSON)
function makeClientHtml(pack){
  const safe = x=> String(x||'').replace(/[&<>]/g, s=>({ '&':'&amp;','<':'&lt;','>':'&gt;'})[s]);
  const rows = (pack.items||[]).map(it=>{
    const props = (it.propositions||[]).map(p=>`
      <tr>
        <td>${safe(p.pid)}</td>
        <td>${safe(p.label)}</td>
        <td>
          <select data-pid="${safe(p.pid)}" data-card="${safe(it.id)}">
            <option value="valide">Valider</option>
            <option value="a_preciser" selected>À préciser</option>
            <option value="refuse">Refuser</option>
          </select>
        </td>
        <td><input type="text" data-cmt="1" data-pid="${safe(p.pid)}" data-card="${safe(it.id)}" placeholder="Commentaire"></td>
      </tr>`).join('');
    return `
      <section style="margin:12px 0;padding:10px;border:1px solid #eee;border-radius:8px">
        <h3>${safe(it.title||it.reformulation||'(sujet)')}</h3>
        <table border="1" cellpadding="6" style="border-collapse:collapse;width:100%">
          <thead><tr><th>PID</th><th>Proposition</th><th>Décision</th><th>Commentaire</th></tr></thead>
          <tbody>${props}</tbody>
        </table>
      </section>`;
  }).join('');

  return `<!doctype html><meta charset="utf-8"><title>Formulaire client — ${safe(pack.service)}</title>
  <h2>Validation — ${safe(pack.service)}</h2>
  <p>Choisissez une décision pour chaque proposition, ajoutez un commentaire si besoin, puis <b>Télécharger les réponses</b> (ou Imprimer → PDF).</p>
  ${rows}
  <button id="dl">Télécharger les réponses (JSON)</button>
  <button onclick="window.print()">Imprimer/PDF</button>
  <script>
    document.getElementById('dl').onclick = ()=>{
      const picks = [];
      document.querySelectorAll('select[data-pid]').forEach(sel=>{
        const pid=sel.getAttribute('data-pid');
        const cid=sel.getAttribute('data-card');
        const decision=sel.value;
        const cmt = (document.querySelector('input[data-cmt][data-pid="'+pid+'"][data-card="'+cid+'"]')||{}).value||'';
        picks.push({card_id:cid,pid,decision,comment:cmt});
      });
      const blob = new Blob([JSON.stringify({ responses:picks },null,2)],{type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'reponses_client.json';
      a.click();
    };
  <\/script>`;
}

//   ====== PROJECTEUR : inline ======  
function chip(t){ return `<span style="border:1px solid #ddd;border-radius:999px;padding:2px 8px;margin-right:6px">${t}</span>`; }
function stateBadge(p){ const map={discovery:'#A8B0B9',pret_projecteur:'#2463EB',en_validation:'#F59E0B',bouclee:'#10B981'}; const c=map[p]||'#A8B0B9'; return `<span style="background:${c};color:#fff;border-radius:6px;padding:2px 8px">${p||'—'}</span>`; }
function originTag(origin, who){
  // Normalise
  const label = origin
    || (who==='guest' ? 'Client' : who==='operator' ? 'SenIAr' : '—');
  const text  = (label==='ClientImport') ? 'Client (import)' : label;

  // Couleurs
  const colMap = {
    'IA':'#7c3aed',          // violet
    'Client':'#0ea5e9',      // bleu
    'ClientImport':'#0284c7',// bleu + foncé
    'SenIAr':'#14b8a6',      // turquoise
    '—':'#9ca3af'
  };
  const col = colMap[label] || '#9ca3af';

  return `<span style="display:inline-block;background:${col};color:#fff;border-radius:999px;padding:2px 8px;font-size:12px;line-height:18px">${text}</span>`;
}

// -- helpers communs
function htmlEscape(s){ return (s??'').toString().replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

function labelOf(it){ return htmlEscape(it?.title || it?.reformulation || '(sujet)'); }

function importBadge(dec){ return (dec?.import_file) ? `<span style="border:1px solid #60a5fa;border-radius:6px;padding:1px 6px;margin-left:6px">fichier: ${htmlEscape(dec.import_file)}</span>` : ''; }

function simsHtml(it,p){
  const sims=(p.sims||[]);
  return sims.map(sm=>`
    <div style="border:1px dashed #ddd;border-radius:6px;padding:8px;margin-top:6px">
      <div style="display:flex;align-items:center;gap:8px;font-size:12px;opacity:.9">
        <button class="spick" data-c="${it.id}" data-p="${p.pid}" data-s="${sm.id}" title="Sélectionner cette simulation">${sm.picked?'★':'☆'}</button>
        ${originTag(sm.origin||'IA')}
        <span>${htmlEscape(sm.id||'S')}</span>
        <span>${sm.ts? new Date(sm.ts).toLocaleTimeString(): ''}</span>
      </div>
      <div style="margin:4px 0">${htmlEscape(sm.note||'')}</div>
      <div style="font-size:12px;opacity:.8">impact: coût ${htmlEscape(sm.impact?.cout??'—')} · délai ${htmlEscape(sm.impact?.delai??'—')} · risque ${htmlEscape(sm.impact?.risque??'—')}</div>
    </div>`).join('');
}

function notesHtml(p){
  return (p.notes||[]).slice(-6).map(n=>`
    <div style="display:flex;gap:8px;align-items:baseline;margin-top:6px">
      ${originTag(n.origin, n.who)}
      <span style="font-size:12px;opacity:.7">${n.ts? new Date(n.ts).toLocaleTimeString(): ''}</span>
      <div>${htmlEscape(n.text||'')}</div>
    </div>`).join('');
}

// -- rendu projeteur commun (card)
function renderCardCommon(it){
  const props=(it.propositions||[]);
  const propsHtml = props.map((p,i)=>{
    const st=(p.decision?.status)||'a_preciser';
    const is = s=> (st===s ? 'class="pact active"' : 'class="pact"');
    return `
    <div style="border:1px solid #eee;border-radius:8px;padding:10px;margin-bottom:12px">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
        <div><strong>${htmlEscape(p.pid||('P'+(i+1)))}</strong> · ${htmlEscape(p.label||'')}</div>
        <div>
          <button ${is('valide')}      data-c="${it.id}" data-p="${p.pid}" data-act="valide" style="margin-right:6px">Valider</button>
          <button ${is('a_preciser')}  data-c="${it.id}" data-p="${p.pid}" data-act="a_preciser" style="margin-right:6px">À préciser</button>
          <button ${is('refuse')}      data-c="${it.id}" data-p="${p.pid}" data-act="refuse">Refuser</button>
          ${importBadge(p.decision)}
        </div>
      </div>
      <div style="opacity:.8;margin:4px 0">coût:${htmlEscape(p.indicateurs?.cout??'—')} · complexité:${htmlEscape(p.indicateurs?.complexite??'—')} · embauche:${htmlEscape(p.indicateurs?.embauche??'—')} · données:${htmlEscape(p.indicateurs?.donnees??'—')}</div>
      <label style="font-size:.9em;opacity:.8">Commentaire</label>
      <div style="display:flex;gap:6px;align-items:center">
			  <input type="text" class="pcmt" data-c="${it.id}" data-p="${p.pid}" value="${htmlEscape(p.decision?.comment||'')}" style="width:100%">
			  <button class="psim" data-c="${it.id}" data-p="${p.pid}">⚡</button><button class="ppick" data-c="${it.id}" data-p="${p.pid}" title="Sélectionner sans IA">${(p.decision?.star)?'★':'☆'}</button>
			</div>
      <div style="margin-top:8px">${simsHtml(it,p)}</div>
      <div style="margin-top:6px">${notesHtml(p)}</div>
    </div>`;
  }).join('');

  return `
  <div class="card">
 		<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
			<div style="font-weight:700;font-size:16px">${labelOf(it)}</div>
			<button class="ppin" data-c="${it.id}" title="Épingler dans la séance">📌</button>
		</div>
    <div id="propList">${propsHtml || '<em>Aucune proposition.</em>'}</div>
  </div>`;
}

// -- handlers communs (Valider/À préciser/Refuser, commentaire, sélection simu)
function attachCardHandlers(root, getState, setState, onChange){
  // décisions
  root.querySelectorAll('.pact').forEach(b=>{
    b.onclick = ()=>{
      const c = b.getAttribute('data-c'); const pid = b.getAttribute('data-p'); const act = b.getAttribute('data-act');
      const S = getState(); const it = (S.items||[]).find(x=>String(x.id)===String(c)); if(!it) return;
      const p = (it.propositions||[]).find(pp=>String(pp.pid)===String(pid)); if(!p) return;
      p.decision = p.decision||{}; p.decision.status = act; p.decision.ts = Date.now();
      setState(S); onChange && onChange();
    };
  });
  // commentaire
  root.querySelectorAll('.pcmt').forEach(inp=>{
    inp.onchange = ()=>{
      const c = inp.getAttribute('data-c'); const pid = inp.getAttribute('data-p');
      const S = getState(); const it = (S.items||[]).find(x=>String(x.id)===String(c)); if(!it) return;
      const p = (it.propositions||[]).find(pp=>String(pp.pid)===String(pid)); if(!p) return;
      p.decision = p.decision||{}; p.decision.comment = inp.value; p.decision.ts = Date.now();
      setState(S); onChange && onChange();
    };
  });
	// simulation IA (⚡) : prend le commentaire courant comme note source
	root.querySelectorAll('.psim').forEach(btn=>{
	  btn.onclick = async ()=>{
	    const c = btn.getAttribute('data-c'); const pid = btn.getAttribute('data-p');
	    const S = getState(); const it = (S.items||[]).find(x=>String(x.id)===String(c)); if(!it) return;
	    const p = (it.propositions||[]).find(pp=>String(pp.pid)===String(pid)); if(!p) return;
	    const cmt = root.querySelector(`.pcmt[data-c="${c}"][data-p="${pid}"]`)?.value || '';
	    const old = btn.textContent; btn.textContent='⚡…'; btn.disabled=true;
	    try { await runSim(it, p, cmt); setState(S); onChange && onChange(); }
	    finally { btn.disabled=false; btn.textContent=old; }
	  };
	});

	// sélection directe (☆/★) de la proposition, même sans simu
	root.querySelectorAll('.ppick').forEach(btn=>{
	  btn.onclick = ()=>{
	    const c = btn.dataset.c, pid = btn.dataset.p;
	    const S = getState();
	    const it = (S.items||[]).find(x=>String(x.id)===String(c)); if(!it) return;
	    const p = (it.propositions||[]).find(pp=>String(pp.pid)===String(pid)); if(!p) return;
	    p.decision = p.decision || {};
	    p.decision.star = !p.decision.star;
	    p.decision.ts = Date.now();
	    setState(S);
	    onChange && onChange();
	  };
	});
	
  // épingler la carte courante dans la séance (et forcer l’affichage local)
	root.querySelectorAll('.ppin').forEach(btn=>{
		const isInlineProjector = (root && root.id === 'projCard'); // operator inline vs viewer
		const c = btn.getAttribute('data-c');
		const pinned = (typeof window._projSel !== 'undefined') ? (window._projSel===null? null : String(window._projSel)) : null;
		const isPinned = (pinned && String(c)===String(pinned));
		// reflect state
		btn.setAttribute('aria-pressed', String(!!isPinned));
		if (!isInlineProjector){
			// viewer: passive
			btn.setAttribute('aria-disabled','true');
			return;
		}
		// operator: toggle on click
		btn.onclick = ()=>{
			const next = isPinned ? null : c;
			window._projSel = next;
			try{ renderProjectorInline && renderProjectorInline(); }catch(_){}
			try{ logEvent && logEvent('pin_card', { card_id: next }); }catch(_){}
			try{ pushEventLive && pushEventLive({ type:'pin_card', service: currentService(), card_id: next }); }catch(_){}
		};
	});
	
	// sélection simu ☆/★
  root.querySelectorAll('.spick').forEach(btn=>{
    btn.onclick = ()=>{
      const c = btn.getAttribute('data-c'); const pid = btn.getAttribute('data-p'); const sid = btn.getAttribute('data-s');
      const S = getState(); const it = (S.items||[]).find(x=>String(x.id)===String(c)); if(!it) return;
      const p = (it.propositions||[]).find(pp=>String(pp.pid)===String(pid)); if(!p) return;
      const sm = (p.sims||[]).find(s=>String(s.id)===String(sid)); if(!sm) return;
      sm.picked = !sm.picked; sm.ts_pick = Date.now();
      setState(S); onChange && onChange();
    };
  });
}

function renderProjectorInline(){
  const s=svc();
  const items=(s.items||[]);
	const it = items.find(x=>x.id===window._projSel) || items[items.length-1];
	const ch = document.getElementById('cardHdr'); 
	if (ch) ch.textContent = it?.id || '—';
  const list=document.getElementById('projAgendaList');
  const card=document.getElementById('projCard');
	if(!it){
	  list.innerHTML = '<li>—</li>';
	  card.innerHTML='<em>Analyse un item dans “Capture” pour l’afficher ici, ou ouvre le Projecteur.</em>';
	  return;
	}
  const chips = (s.charter?.contraintes||'').split(/[;,•\n]/).map(x=>x.trim()).filter(Boolean).slice(0,4).map(chip).join(' ') || chip('—');
  function pill(dec){ 
    const st=(dec?.status)||'a_preciser';
    const src = dec?.source==='client' ? ' <span style="border:1px solid #60a5fa;border-radius:6px;padding:1px 6px;margin-left:6px">client</span>' : '';
    return `<span class="status-pill"><span class="dot ${st}"></span>${st.replace('_',' ')}</span>`;
  }
	const sel = window._projSel || (items[items.length-1]?.id);
	list.innerHTML = items.map(x=>{
	  const cur = (x.id===sel) ? 'font-weight:700;text-decoration:underline;' : '';
	  const label = x.title || x.reformulation || '—';
	  return `<li style="margin:6px 0"><a href="#" data-c="${x.id}" style="${cur}">${label}</a></li>`;
	}).join('') || '<li>—</li>';
	
	list.querySelectorAll('a[data-c]').forEach(a=>{
	  a.onclick=(e)=>{ e.preventDefault(); window._projSel=a.dataset.c; renderProjectorInline(); };
	});
	  // ---- Rendu card + handlers (page type)
	  card.innerHTML = renderCardCommon(it);
	  attachCardHandlers(
	    card,
	    ()=>svc(),
	    (S)=>{ touch(); },
	    ()=>{ renderProjectorInline(); }
	  );
}

btnOpenProjector.onclick = ()=>{
  // 1) Aligne le WID sur le service/date affichés
  if (typeof bindWork==='function') bindWork();

  // 2) Ouvre le projecteur en standalone (avec proxy si dispo)
  const base = location.href.split('?')[0];
  const url = new URL(base);
  url.searchParams.set('projecteur','1');
  const prox = gasUrl(); if (prox) url.searchParams.set('prox', prox);
  window.open(url.toString(),'projecteur_'+(localStorage.getItem(WORK_KEY)||''),'noopener');
};

//   ====== SCÉNARIOS ======  
btnForkScenario.onclick = ()=>{
  const s=svc();
  (s.scenarios||(s.scenarios=[]));
  s.scenarios = Array.isArray(s.scenarios) ? s.scenarios : [];
	const id = nextScenarioId();
	const snap = {
	  charter: s.charter || {},
	  items: JSON.parse(JSON.stringify(s.items||[])),
	  decisions: JSON.parse(JSON.stringify(s.decisions||[]))
	};
	s.scenarios.push({ id, snapshot: snap, ts: Date.now() });
	touch(); renderScList(); 
};

btnPromoteScenario.onclick = ()=>{
  const s=svc(); if(!s.scenarios?.length) return alert('Aucun scénario.');
  const cur = localStorage.getItem('paria_sel_scenario') || '';
  const chosen = s.scenarios.find(x=>x.id===cur) || s.scenarios[s.scenarios.length-1];
  const snap = chosen.snapshot || {};
  s.items     = Array.isArray(snap.items)     ? JSON.parse(JSON.stringify(snap.items))     : (s.items||[]);
  s.decisions = Array.isArray(snap.decisions) ? JSON.parse(JSON.stringify(snap.decisions)) : (s.decisions||[]);
  touch(); renderScList(); alert(`Scénario ${chosen.id} promu (items & décisions).`);
};

function renderScList(){
  const s = svc(); const el = document.getElementById('scList');
  if(!s.scenarios?.length){ el.innerHTML='<em>Aucun scénario.</em>'; return; }

  // bornes: lundi de la semaine courante (S0) + lundi de S-1
  const today = new Date(); const day = (today.getDay()+6)%7; // 0=lundi
  const monday0 = new Date(today); monday0.setDate(today.getDate()-day);
  const mondaym1 = new Date(monday0); mondaym1.setDate(monday0.getDate()-7);
  const days = [...Array(14)].map((_,i)=> {
    const d = new Date(mondaym1); d.setDate(mondaym1.getDate()+i);
    return d;
  });

  // indexer les scénarios par jour (YYYY-MM-DD)
  const keyOf = d => d.toISOString().slice(0,10);
  const buckets = {}; (s.scenarios||[]).forEach(sc=>{
    const k = keyOf(new Date(sc.ts||Date.now()));
    (buckets[k]||(buckets[k]=[])).push(sc);
  });

  // rendu grille: 2 lignes de 7 colonnes
  const cell = (d)=>{
    const k = keyOf(d);
    const list = (buckets[k]||[]).map(sc=>{
      const time = new Date(sc.ts).toLocaleTimeString().slice(0,5);
      return `
        <button class="scDot" data-id="${sc.id}" title="${time}">
          ${sc.id}
          <span class="scDel" data-id="${sc.id}" title="Supprimer">✕</span>
        </button>`;
    }).join('');
    const dd = `${String(d.getDate()).padStart(2,'0')}/${String(d.getMonth()+1).padStart(2,'0')}`;
    return `<div class="scCell"><div class="scDate">${dd}</div><div class="scList">${list||''}</div></div>`;
  };

  el.innerHTML = `
    <div class="scGrid">
      ${days.slice(0,7).map(cell).join('')}
      ${days.slice(7).map(cell).join('')}
    </div>
    <style>
      .scGrid{display:grid;grid-template-columns:repeat(7,1fr);gap:8px}
      .scCell{background:#fff;border:1px solid #eee;border-radius:8px;padding:8px;min-height:64px}
      .scDate{font-size:12px;opacity:.7;margin-bottom:6px}
      .scList{display:flex;flex-wrap:wrap;gap:6px}
      .scDot{position:relative;border:1px solid #ddd;border-radius:12px;padding:2px 6px;background:#fafafa;cursor:pointer}
      .scDot .scDel{display:none;position:absolute;top:-8px;right:-8px;background:#ef4444;color:#fff;
                    border-radius:50%;width:18px;height:18px;line-height:18px;text-align:center;font-size:12px}
      .scDot:hover .scDel{display:inline-block}
    </style>
  `;

  // ouvrir scénario
  el.querySelectorAll('.scDot').forEach(b=>{
    b.onclick = (e)=>{
      if (e.target.classList.contains('scDel')) return; // laisser le delete gérer
      localStorage.setItem('paria_sel_scenario', b.dataset.id);
      document.getElementById('scWork').innerHTML = '';
      openScenario(b.dataset.id);
    };
  });

  // supprimer scénario
  el.querySelectorAll('.scDel').forEach(x=>{
    x.onclick = (e)=>{
      e.stopPropagation();
      const id = x.dataset.id;
      const i = (s.scenarios||[]).findIndex(z=>z.id===id);
      if (i>=0) s.scenarios.splice(i,1);
      touch(); renderScList();
      document.getElementById('scWork').innerHTML = '';
    };
  });
}


//   ====== Projecteur standalone interactif (plein écran) ======  
(function maybeStandaloneProjector(){
  const params = new URL(location.href).searchParams;
  if(params.get('projecteur')!=='1') return;
	const qpProx = params.get('prox');
	if (qpProx && (!gasUrl() || gasUrl()!==qpProx)) { setGasUrl(qpProx); }

  function loadLocal(){ try{ return JSON.parse(localStorage.getItem(DB_KEY)||'{"services":{}}'); }catch(e){ return {services:{}}; } }
  function saveLocal(x){ localStorage.setItem(DB_KEY, JSON.stringify(x)); touch(); }

  document.body.innerHTML = `
    <div class="full" style="font-size:16px">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div><strong>Projecteur</strong> — <span id="p_hdr">—</span></div>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <button id="p_prev">◀</button>
          <button id="p_next">▶</button>
          <button id="p_big">A+</button>
          <button id="p_small">A−</button>
          <button id="p_toggle_agenda">Afficher/Masquer Agenda</button>
          <small style="opacity:.7">F11 plein écran · ←/→ naviguer · 1/2/3 décider</small>
        </div>
      </div>
      <div id="p_grid" class="gridProj">
        <aside id="p_agenda" style="border:1px solid #ddd;border-radius:10px;padding:10px;max-height:74vh;overflow:auto"></aside>
        <main id="p_card" style="border:1px solid #ddd;border-radius:10px;padding:16px;min-height:70vh;background:#fff"></main>
      </div>
    </div>
  `;

  const hdr   = document.getElementById('p_hdr');
  const grid  = document.getElementById('p_grid');
  const agenda= document.getElementById('p_agenda');
  const card  = document.getElementById('p_card');
  const btnPrev = document.getElementById('p_prev');
  const btnNext = document.getElementById('p_next');
  const btnBig  = document.getElementById('p_big');
  const btnSmall= document.getElementById('p_small');
  const btnTogA = document.getElementById('p_toggle_agenda');
	const qp = new URL(location.href).searchParams;
	const qpSec = qp.get('ps');  if (qpSec) setProxySecret(qpSec);
	const qpWid = qp.get('wid'); if (qpWid) localStorage.setItem(WORK_KEY, qpWid);


	// --- SYNC INVITÉ (session events) ---
	let guest = { session:null, role:null, token:null, last_seq:0, poll:null };

	function isGuestMode(){
		const p = new URL(location.href).searchParams;
		return p.get('role') === 'guest' && p.get('session') && p.get('token');
	}
	function readGuestParams(){
		const p = new URL(location.href).searchParams;
		guest.session = p.get('session'); guest.role = 'guest'; guest.token = p.get('token');
	}
	async function pollGuestEvents(){
		if(!guest.session) return;
		try{
			const j = await (async ()=>{
				const u = new URL(gasUrl());
				u.searchParams.set('route','events_since');
				u.searchParams.set('secret', proxySecret());
				u.searchParams.set('session_id', guest.session);
				u.searchParams.set('token', guest.token);
				u.searchParams.set('after', String(guest.last_seq||0));
				const r = await fetch(u.toString());
				return await r.json();
			})();
			if(!j.ok) return;
			(j.events||[]).forEach(ev=>{
				guest.last_seq = Math.max(guest.last_seq, ev.seq||0);
				applyIncomingEventToLocal(ev);
			});
		}catch(e){}
	}

	async function loadBaselineFromCloud(){
	  const u = gasUrl(); const sec = proxySecret(); const wid = localStorage.getItem(WORK_KEY)||'';
	  if(!u || !sec || !wid) return false;
	  try{
	    const r = await fetch(`${u}?route=load&secret=${encodeURIComponent(sec)}&work_id=${encodeURIComponent(wid)}`);
	    const j = await r.json();
	    if(j.ok && j.data){
	      state.db = loadLocal(); state.db.services = state.db.services || {};
	      const svcKey = (wid.split('|')[1] || 'Compta');
	      state.db.services[svcKey] = (j.data && j.data.charter)
					? j.data 
					: Object.assign(
		      		{ charter:{}, items:[], decisions:[], scenarios:[] },
		      		(j && j.data) ? j.data : {}
		    		);
	      saveLocal(state.db);
	      return true;
	    }
	  }catch(_){}
	  return false;
	}

	function startGuestPoll(){
		stopGuestPoll();
		guest.poll = setInterval(pollGuestEvents, 1500);
	}
	function stopGuestPoll(){ if(guest.poll){ clearInterval(guest.poll); guest.poll=null; } }

	// Applique un event reçu sur l'état local du projecteur
	function applyIncomingEventToLocal(ev){  if(ev && ev.type==='pin_card'){ window._projSel = ev.card_id || null; try{ renderProjectorInline && renderProjectorInline(); }catch(_){} return; }

		const e = ev.event||{};
		const items = state.svc.items || [];
		if(e.type==='prop_decision'){
			const it = (state.svc.items||[]).find(x=>x.id===e.card_id);
			const p  = (it.propositions||[]).find(pp=>pp.pid===e.pid); if(!p) return;
			p.decision = p.decision || {status:'a_preciser', comment:''};
			if(e.status) p.decision.status = e.status;
			if(e.comment!==undefined) p.decision.comment = e.comment;
			it.pipeline = recomputePipelineForItem(it);
			saveLocal(state.db); renderCard();
		}
		
		if(e.type==='pin_card'){
		  try{
		    if (e.service && e.service !== state.svcKey) {
		      state.svcKey = e.service;
		      state.svc = (state.db.services||{})[e.service] || {items:[],decisions:[],scenarios:[],charter:{}};
		    }
		    state.agendaIds = computeAgenda();
		    const id = e.card_id;
		    const idx = (state.agendaIds||[]).indexOf(id);
		    if (idx >= 0) state.idx = idx;
		    window._projSel = id;
		    renderProjectorInline();
		  }catch(_){}
		  return;
		}

		if(e.type==='comment'){
			const it = (s.items||[]).find(x=>x.id===e.card_id); if(!it) return;
			const prop = (it.propositions||[]).find(pp=>pp.pid===e.pid); if(!prop) return;
			const origin = (ev.role==='guest') ? 'Client' : 'SenIAr';
			(prop.notes||(prop.notes=[])).push({
				ts: ev.ts || Date.now(),
				origin, who: ev.role,
				text: e.text||''
			});
			touch();
			try{
				if(!document.getElementById('tab-projecteur').classList.contains('hide')){
					renderProjectorInline();
				}
			}catch(_){}
		}
		// (plus tard) sim_create ...
	}

  function chip(t){ return `<span style="border:1px solid #ddd;border-radius:999px;padding:2px 8px;margin-right:6px">${t}</span>`; }
  
	function stateBadge(p){ const map={discovery:'#A8B0B9',pret_projecteur:'#2463EB',en_validation:'#F59E0B',bouclee:'#10B981'}; const c=map[p]||'#A8B0B9'; return `<span style="background:${c};color:#fff;border-radius:6px;padding:2px 8px">${p||'—'}</span>`; }
  
	function block(label,arr){ 
		if(!Array.isArray(arr)||!arr.length) return ''; 
		return `<div><strong>${label}</strong><ul style="margin:6px 0 12px 22px">${arr.slice(0,6).map(x=>`<li>${x}</li>`).join('')}</ul></div>`;
	}

  let state = { db: loadLocal(), svcKey: null, svc: null, agendaIds: [], idx: 0 };

  function deriveService(){
    const wid = localStorage.getItem(WORK_KEY)||'';
    const parts = wid.split('|');
    return parts[1] || Object.keys(state.db.services||{})[0] || 'Compta';
  }
  function computeAgenda(){
    const items = state.svc.items||[];
    const ag = Array.isArray(state.svc.agenda)&&state.svc.agenda.length ? state.svc.agenda.slice() : items.map(x=>x.id);
    return ag.filter(id => items.some(x=>x.id===id));
  }
  function renderAgenda(){
    const items = state.svc.items||[];
    const html = state.agendaIds.map((cid,i)=>{
      const it = items.find(x=>x.id===cid);
      const cur = (i===state.idx) ? 'font-weight:700;text-decoration:underline;' : '';
      const label = (it?.title || it?.reformulation || '—'); 
      return `<li style="margin:6px 0"><a href="#" data-i="${i}" style="${cur}">${label}</a></li>`;
    }).join('');
    agenda.innerHTML = `<h4 style="margin:0 0 8px 0">Agenda</h4><ol style="margin:0;padding-left:18px">${html||'<li>—</li>'}</ol>`;
    agenda.querySelectorAll('a[data-i]').forEach(a=>{
      a.onclick=(e)=>{ e.preventDefault(); state.idx=parseInt(a.dataset.i,10)||0; renderCard(); };
    });
  }
  function decide(cardId, pid, status, comment){
    const items = state.svc.items||[];
    const it = items.find(x=>x.id===cardId); if(!it) return;
    const p  = (it.propositions||[]).find(pp=>pp.pid===pid); if(!p) return;
    p.decision = p.decision || {status:'a_preciser', comment:''};
    if(status) p.decision.status = status;
    if(comment!==undefined) p.decision.comment = comment;
    const all = (it.propositions||[]).every(x=>x.decision && x.decision.status && x.decision.status!=='pending');
    it.pipeline = recomputePipelineForItem(it);
    (it.history||(it.history=[])).push({ts:Date.now(), who:'client', what:`${pid}=${p.decision.status}${p.decision.comment?' ('+p.decision.comment+')':''}`});
    saveLocal(state.db); renderCard();
  }
  function renderCard(){
    const items = state.svc.items||[];
    if(!state.agendaIds.length){ card.innerHTML = '<em>Aucun item.</em>'; return; }
    if(state.idx<0) state.idx=0; if(state.idx>=state.agendaIds.length) state.idx = state.agendaIds.length-1;
    const cid = state.agendaIds[state.idx];
    const it  = items.find(x=>x.id===cid);
    if(!it){ card.innerHTML='<em>Item introuvable.</em>'; return; }
    const chips = (state.svc.charter?.contraintes||'').split(/[;,•\n]/).map(x=>x.trim()).filter(Boolean).slice(0,4).map(chip).join(' ') || chip('—');
    const props = (it.propositions||[]).map((p,i)=>{
		  const st=(p.decision?.status)||'a_preciser';
		  const is = s=> (st===s ? 'class="pact active"' : 'class="pact"');
		  const importTag = p.decision?.import_file 
		      ? `<span style="border:1px solid #60a5fa;border-radius:6px;padding:1px 6px;margin-left:6px">fichier: ${p.decision.import_file}</span>` 
		      : '';
			// NEW: sims + notes + badges IA/Client/SenIAr
		  const sims = (p.sims||[]).map(sm=>`
		    <div style="border:1px dashed #ddd;border-radius:6px;padding:8px;margin-top:6px">
		      <div style="display:flex;align-items:center;gap:8px;font-size:12px;opacity:.9">
		        <button class="spick" data-c="${it.id}" data-p="${p.pid}" data-s="${sm.id}" title="Sélectionner cette simulation">${sm.picked?'★':'☆'}</button>
		        ${originTag(sm.origin||'IA')}
		        <span>${sm.id} · ${new Date(sm.ts).toLocaleTimeString()}</span>
		      </div>
		      <div style="margin:4px 0">${(sm.note||'').replace(/</g,'&lt;')}</div>
		      <div style="font-size:12px;opacity:.8">impact: coût ${sm.impact?.cout||'—'} · délai ${sm.impact?.delai||'—'} · risque ${sm.impact?.risque||'—'}</div>
		    </div>`).join('');
		
		  const notes = (p.notes||[]).slice(-6).map(n=>`
		    <div style="display:flex;gap:8px;align-items:baseline;margin-top:6px">
		      ${originTag(n.origin, n.who)}
		      <span style="font-size:12px;opacity:.7">${new Date(n.ts).toLocaleTimeString()}</span>
		      <div>${(n.text||'').replace(/</g,'&lt;')}</div>
		    </div>`).join('');
      return `
      <div style="border:1px solid #eee;border-radius:8px;padding:10px;margin-bottom:12px">
		    <div style="display:flex;justify-content:space-between;align-items:center">
		      <div><strong>${p.pid||('P'+(i+1))}</strong> · ${p.label||''}</div>
		      <div>
		        <button ${is('valide')}      data-c="${it.id}" data-p="${p.pid}" data-act="valide" style="margin-right:6px">Valider</button>
		        <button ${is('a_preciser')}  data-c="${it.id}" data-p="${p.pid}" data-act="a_preciser" style="margin-right:6px">À préciser</button>
		        <button ${is('refuse')}      data-c="${it.id}" data-p="${p.pid}" data-act="refuse">Refuser</button>
		        ${importTag}
		      </div>
		    </div>
		    <div style="opacity:.8;margin:4px 0">coût:${p.indicateurs?.cout||'—'} · complexité:${p.indicateurs?.complexite||'—'} · embauche:${p.indicateurs?.embauche||'—'} · données:${p.indicateurs?.donnees||'—'}</div>
		    <label style="font-size:.9em;opacity:.8">Commentaire</label>
		    <input type="text" class="pcmt" data-c="${it.id}" data-p="${p.pid}" value="${p.decision?.comment||''}" style="width:100%">
		    <!-- NEW: sims + notes -->
		    <div style="margin-top:8px">${sims}</div>
		    <div style="margin-top:6px">${notes}</div>
		  </div>`; 
    }).join('');
    card.innerHTML = renderCardCommon(it);
		attachCardHandlers(
		  card,
		  ()=>state.svc,
		  (S)=>{ state.svc = S; saveLocal(state.db); },
		  ()=>{ renderCard(); }
		);
    const __p = document.getElementById('p_prev2'); if (__p) __p.onclick = ()=> { state.idx=Math.max(0,state.idx-1); renderCard(); };
    const __n = document.getElementById('p_next2'); if (__n) __n.onclick = ()=> { state.idx=Math.min(state.agendaIds.length-1,state.idx+1); renderCard(); };
  }
	
  function renderAll(){
    state.db = loadLocal();
    state.svcKey = deriveService();
    state.svc    = state.db.services[state.svcKey] || {charter:{},items:[],agenda:[]};
    state.agendaIds = computeAgenda();
    if(state.idx>=state.agendaIds.length) state.idx = 0;
    const wid = localStorage.getItem(WORK_KEY)||(`— | ${state.svcKey} | —`);
    const cid = state.agendaIds[state.idx] || '—';
		hdr.textContent = `Service projeté : ${state.svcKey} · Card #${cid} · INVITÉ · LIVE`;
    renderAgenda(); renderCard();
  }
	
	loadBaselineFromCloud().finally(()=>{
	  renderAll();
	  if(isGuestMode()){
	    readGuestParams();
	    startGuestPoll();
	  }
	});

  // sync via storage et contrôles
  window.addEventListener('storage', (e)=>{ if(e.key===DB_KEY || e.key==='paria_touch' || e.key===WORK_KEY) renderAll(); });
  btnPrev.onclick = ()=>{ state.idx=Math.max(0,state.idx-1); renderCard(); };
  btnNext.onclick = ()=>{ state.idx=Math.min(state.agendaIds.length-1,state.idx+1); renderCard(); };
  btnBig.onclick  = ()=>{ document.querySelector('.full').style.fontSize='18px'; };
  btnSmall.onclick= ()=>{ document.querySelector('.full').style.fontSize='15px'; };
  btnTogA.onclick = ()=>{ const hidden = agenda.style.display === 'none'; agenda.style.display = hidden ? 'block' : 'none'; grid.classList.toggle('no-agenda', !hidden); };
  window.addEventListener('keydown', (ev)=>{
    if(ev.key==='ArrowLeft'){ btnPrev.click(); ev.preventDefault(); }
    if(ev.key==='ArrowRight'){ btnNext.click(); ev.preventDefault(); }
    if(['1','2','3'].includes(ev.key)){
      const first = card.querySelector('.pact[data-act]'); if(!first) return;
      const c = first.getAttribute('data-c'); const p = first.getAttribute('data-p'); const map = { '1':'valide', '2':'a_preciser', '3':'refuse' };
      decide(c,p,map[ev.key]); ev.preventDefault();
    }
  });
})();

function syncPinState(root){
  if(!root) return;
  const sel = (typeof window._projSel!=='undefined') ? window._projSel : null;
  root.querySelectorAll('.ppin').forEach(btn=>{
    const c = btn.getAttribute('data-c');
    btn.setAttribute('aria-pressed', String(sel && String(sel)===String(c)));
  });
}

//   ===== Cards Tab (atelier) =====  
let _cardsSelId = null;

function cardsFiltered(){
  const S = svc();
  const q = (document.getElementById('cardsSearch')?.value||'').toLowerCase();
  const st = (document.getElementById('cardsStatus')?.value||'').toLowerCase();
  return (S.items||[]).filter(x=>!x.deleted_at).filter(x=>{
    const t = (x.title||x.reformulation||'').toLowerCase();
    const okQ = !q || t.includes(q);
    const okS = !st || (String(x.status||'').toLowerCase()===st);
    return okQ && okS;
  });
}

function renderCardDetail(id){
  const S = svc();
  const it = (S.items||[]).find(x=>String(x.id)===String(id));
  const view = document.getElementById('cardView');
  const pre = document.getElementById('cardJson');
  if(!it){ if(view) view.innerHTML='<em>Non trouvé.</em>'; if(pre) pre.textContent=''; return; }
  if(view){
    const propList = (it.propositions||[]).map(p=>`<li>${p.pid||''} — ${p.label||''}</li>`).join('') || '<li>—</li>';
    view.innerHTML = `
      <div style="font-weight:700;margin-bottom:6px">${it.title||it.reformulation||it.id}</div>
      <div style="font-size:.9em;color:#666;margin-bottom:6px">ID: ${it.id} — statut: ${it.status||'—'}</div>
      <div><b>PARIA</b>: ${ (it.paria? Object.keys(it.paria).join(', ') : '—') }</div>
      <div style="margin-top:4px"><b>Propositions</b>: <ul style="margin:6px 0 0 18px">${propList}</ul></div>
    `;
  }
  if(pre) pre.textContent = JSON.stringify(it, null, 2);

  // wire actions
  const openBtn = document.getElementById('btnCardOpenProj');
  if(openBtn) openBtn.onclick=()=>{ window._projSel = id; renderProjectorInline && renderProjectorInline(); };
  const delBtn = document.getElementById('btnCardDel');
  if(delBtn) delBtn.onclick=()=>{ if(deleteCardById(id)){ renderCardsList(); renderDecisions && renderDecisions(); if(_cardsSelId===id) _cardsSelId=null; } };
  const mdBtn = document.getElementById('btnCardExportMd');
  if(mdBtn) mdBtn.onclick=()=>{ exportCardAs('md', it); };
  const hBtn = document.getElementById('btnCardExportHtml');
  if(hBtn) hBtn.onclick=()=>{ exportCardAs('html', it); };
  const jBtn = document.getElementById('btnCardExportJson');
  if(jBtn) jBtn.onclick=()=>{ exportCardAs('json', it); };
}

// Exports (client-side download)
function downloadText(filename, text){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text], {type:'text/plain;charset=utf-8'}));
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
function exportCardAs(fmt, it){
  if(!it) return;
  if(fmt==='json'){ return downloadText(`card_${it.id}.json`, JSON.stringify(it, null, 2)); }
  if(fmt==='md'){
    const md = `# ${it.title||it.reformulation||it.id}

		**ID:** ${it.id}
		**Statut:** ${it.status||'-'}
		
		## PARIA
		${Object.entries(it.paria||{}).map(([k,v])=>`- **${k}**: ${(v||[]).join('; ')}`).join('\n')}
		
		## Propositions
		${(it.propositions||[]).map(p=>`- ${p.pid||''} — ${p.label||''}`).join('\\n')||'- —'}`;
	  return downloadText(`card_${it.id}.md`, md);
  }
  if(fmt==='html'){
    const html = `<!doctype html><meta charset="utf-8"><title>Card ${it.id}</title><style>body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;line-height:1.4;padding:24px;max-width:900px;margin:auto}</style><h1>${it.title||it.reformulation||it.id}</h1><p><b>ID:</b> ${it.id} — <b>Statut:</b> ${it.status||'-'}</p><h2>PARIA</h2><ul>${Object.entries(it.paria||{}).map(([k,v])=>`<li><b>${k}</b>: ${(v||[]).join('; ')}</li>`).join('')}</ul><h2>Propositions</h2><ul>${(it.propositions||[]).map(p=>`<li>${p.pid||''} — ${p.label||''}</li>`).join('')}</ul>`;
    return downloadText(`card_${it.id}.html`, html);
  }
}

// ---------- Helpers sûrs ----------
function safeLog(type, payload){
  try { if (typeof logEvent === 'function') logEvent(type, payload||{}); } catch(e){}
  try {
	  if (typeof pushEventLive === 'function') {
	    pushEventLive(Object.assign({ type: type }, (payload || {})));
	  }
	} catch (e) {}
}
function download(name, content){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([content], {type:'text/plain;charset=utf-8'}));
  a.download = name; a.click(); URL.revokeObjectURL(a.href);
}

// ---------- Pinned ----------
function isPinned(id){ const s=svc(); return String(s.pinned_card||'')===String(id); }
function pinCardInProjector(id){
  const s=svc(); s.pinned_card = String(id); touch();
  safeLog('pin_card', {card_id:String(id)});
  if (typeof renderProjectorInline==='function') renderProjectorInline();
}

// ---------- Restore/Delete ----------
function softDeleteCard(id){
  const s = svc();
  const it = (s.items||[]).find(x=>String(x.id)===String(id));
  if (!it) return false;

  const snap = JSON.parse(JSON.stringify(it));
  it.deleted_ts = Date.now();
  delete it.deleted_at; // normalise le flag
  touch();

  logEvent('card_deleted', { refs:{ card_id:String(id) }, service:(typeof currentService==='function'?currentService():undefined), snap:{ card:snap } });
  if (typeof renderDecisions==='function') renderDecisions();
  if (typeof renderCardsList==='function') renderCardsList();
  return true;
}

window.restoreCardById = restoreCardById; // utilisé par Journal (bouton "Restaurer")

// ---------- Cards: rendering ----------
function renderCardsTab(){
  // guards si l'onglet n'est pas dans le DOM
  const root = document.getElementById('tab-cards'); if (!root) return;
  const q = document.getElementById('cardsSearch');
  const st= document.getElementById('cardsStatus');
  // listeners uniques
  if (q && !q._bound){ q._bound = true; q.addEventListener('input', renderCardsList); }
  if (st && !st._bound){ st._bound = true; st.addEventListener('change', renderCardsList); }
  renderCardsList();
}

function renderCardsList(){
  const s=svc();
  const listEl = document.getElementById('cardsList'); if(!listEl) return;
  const q = (document.getElementById('cardsSearch')?.value||'').toLowerCase();
  const st= (document.getElementById('cardsStatus')?.value||'');

  const items = (s.items||[])
    .filter(it => !it?.deleted_ts)
    .filter(it => !st || (it.decision?.status===st || it.status===st))
    .filter(it => {
      if(!q) return true;
      const text = [it.title, it.reformulation].filter(Boolean).join(' ').toLowerCase();
      return text.includes(q);
    });

  if(!items.length){
    listEl.innerHTML = '<div style="padding:8px;opacity:.7"><em>Aucune card.</em></div>';
    document.getElementById('cardView')?.replaceChildren(document.createTextNode('—'));
    document.getElementById('cardJson')?.replaceChildren(document.createTextNode('—'));
    return;
  }

  listEl.innerHTML = items.map(it=>{
    const label = it.title || it.reformulation || ('Card '+it.id);
    const pin = isPinned(it.id) ? ' (pinned)' : '';
    return `<a href="#" data-id="${String(it.id)}" class="pill" style="display:block;margin:6px">${label}${pin}</a>`;
  }).join('');

  listEl.querySelectorAll('a[data-id]').forEach(a=>{
    a.onclick=(e)=>{ e.preventDefault(); openCardDetail(a.getAttribute('data-id')); };
  });
}

function openCardDetail(id){
  const s=svc(); const it=(s.items||[]).find(x=>String(x.id)===String(id)); if(!it) return;
  const view = document.getElementById('cardView');
  const jpre = document.getElementById('cardJson');
  if (view) {
    const label = it.title || it.reformulation || ('Card '+it.id);
    const pinned = isPinned(id);
    view.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
        <strong>${label}</strong>
        <button class="ppin" aria-pressed="${pinned?'true':'false'}" title="${pinned?'Épinglée':'Épingler'}"></button>
      </div>
      <div style="margin-top:8px"><pre style="white-space:pre-wrap">${(it.title||it.reformulation||'').trim()}</pre></div>
    `;
    const pinBtn = view.querySelector('.ppin');
    if (pinBtn && !pinBtn._bound){
      pinBtn._bound = true;
      pinBtn.onclick=()=>{ pinCardInProjector(id); openCardDetail(id); };
    }
  }
  if (jpre) jpre.textContent = JSON.stringify(it,null,2);

  // Boutons actions
  const bOpen = document.getElementById('btnCardOpenProj');
  const bDel  = document.getElementById('btnCardDel');
  const bJ    = document.getElementById('btnCardExportJson');
  const bMd   = document.getElementById('btnCardExportMd');
  const bHtml = document.getElementById('btnCardExportHtml');

  if (bOpen){ bOpen.onclick=()=>{ pinCardInProjector(id); }; }
  if (bDel){  bDel.onclick =()=>{ softDeleteCard(id); renderCardsList(); }; }
  if (bJ){    bJ.onclick   =()=>{ download(`card_${id}.json`, JSON.stringify(it,null,2)); }; }
  if (bMd){   bMd.onclick  =()=>{ download(`card_${id}.md`, toMd(it)); }; }
  if (bHtml){ bHtml.onclick=()=>{ download(`card_${id}.html`, toHtml(it)); }; }
}

// --- exports minimalistes ---
function toMd(it){
  const t = it.title || it.reformulation || ('Card '+it.id);
  const paria = it.paria||{};
  const pariaLines = Object.entries(paria).map(([k,v])=>`- **${k}**: ${(v||[]).join('; ')}`).join('\n');
  return `# ${t}\n\n## PARIA\n${pariaLines}\n`;
}
function toHtml(it){
  const t = it.title || it.reformulation || ('Card '+it.id);
  const paria = it.paria||{};
  const pariaLines = Object.entries(paria).map(([k,v])=>`<li><b>${k}</b>: ${(v||[]).join('; ')}</li>`).join('');
  return `<!doctype html><meta charset="utf-8"><title>${t}</title><h1>${t}</h1><h2>PARIA</h2><ul>${pariaLines}</ul>`;
}
// === CARDS – module minimal (guardé) ===
if (typeof renderCardsTab !== 'function') {
  window.openCardDetail = function(id){
    const s = svc(); const it = (s.items||[]).find(x=>String(x.id)===String(id));
    const v = document.getElementById('cardView');
    const j = document.getElementById('cardJson');
    if (!it || !v || !j) return;
    const title = it.title || it.reformulation || ('Card '+it.id);
    v.innerHTML   = `<strong>${title}</strong>`;
    j.textContent = JSON.stringify(it, null, 2);

    // actions
    const bOpen = document.getElementById('btnCardOpenProj');
    const bDel  = document.getElementById('btnCardDel');
    const bJ    = document.getElementById('btnCardExportJson');
    const bMd   = document.getElementById('btnCardExportMd');
    const bHtml = document.getElementById('btnCardExportHtml');

    if (bOpen) bOpen.onclick = ()=>{ s.pinned_card = String(id); touch(); if (typeof renderProjectorInline==='function') renderProjectorInline(); };
		if (bDel) bDel.onclick = () => {
			const s  = svc();
			const it = (s.items || []).find(x => String(x.id) === String(id));
			if (!it) return;

			// snapshot AVANT suppression (pour restauration et affichage journal)
			const snap = JSON.parse(JSON.stringify(it));

			// soft delete
			it.deleted_ts = Date.now();
			touch();

			// journaliser l’action (append-only)
			logEvent('card_deleted', {
			  refs: { card_id: String(id) },
			  service: (typeof currentService==='function') ? currentService() : undefined,
			  snap: { card: snap }
			});

			// UI
			renderCardsList();
			const v = document.getElementById('cardView'); if (v) v.textContent = '—';
			const j = document.getElementById('cardJson'); if (j) j.textContent = '—';
			if (typeof renderDecisions === 'function') renderDecisions();
		};

    if (bJ)    bJ.onclick    = ()=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([JSON.stringify(it,null,2)],{type:'application/json'})); a.download=`card_${id}.json`; a.click(); URL.revokeObjectURL(a.href); };
    if (bMd)   bMd.onclick   = ()=>{ const md = `# ${title}\n\n## PARIA\n${Object.entries(it.paria||{}).map(([k,v])=>`- **${k}**: ${(v||[]).join('; ')}`).join('\n')}`; const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([md],{type:'text/markdown;charset=utf-8'})); a.download=`card_${id}.md`; a.click(); URL.revokeObjectURL(a.href); };
    if (bHtml) bHtml.onclick = ()=>{ const html = `<!doctype html><meta charset="utf-8"><title>${title}</title><h1>${title}</h1><h2>PARIA</h2><ul>${Object.entries(it.paria||{}).map(([k,v])=>`<li><b>${k}</b>: ${(v||[]).join('; ')}</li>`).join('')}</ul>`; const a=document.createElement('a'); a.href=URL.createObjectURL(new Blob([html],{type:'text/html;charset=utf-8'})); a.download=`card_${id}.html`; a.click(); URL.revokeObjectURL(a.href); };
  };

  window.renderCardsList = function(){
    const s = svc(); const listEl = document.getElementById('cardsList'); if(!listEl) return;
    const q  = (document.getElementById('cardsSearch')?.value||'').toLowerCase();
    const st = (document.getElementById('cardsStatus')?.value||'').toLowerCase();

    const items = (s.items||[])
      .filter(it => !it?.deleted_ts)
      .filter(it => !st || String(it.decision?.status||it.status||'').toLowerCase()===st)
      .filter(it => {
        if(!q) return true;
        const txt = [it.title, it.reformulation].filter(Boolean).join(' ').toLowerCase();
        return txt.includes(q);
      });

    if(!items.length){
      listEl.innerHTML = '<div style="padding:8px;opacity:.7"><em>Aucune card.</em></div>';
      document.getElementById('cardView')?.replaceChildren(document.createTextNode('—'));
      document.getElementById('cardJson')?.replaceChildren(document.createTextNode('—'));
      return;
    }
    listEl.innerHTML = items.map(it=>{
      const label = it.title || it.reformulation || ('Card '+it.id);
      return `<a href="#" data-id="${String(it.id)}" class="pill" style="display:block;margin:6px">${label}</a>`;
    }).join('');

    listEl.querySelectorAll('a[data-id]').forEach(a=>{
      a.onclick=(e)=>{ e.preventDefault(); openCardDetail(a.dataset.id); };
    });
  };

  window.renderCardsTab = function(){
    const sch = document.getElementById('cardsSearch');
    const ss  = document.getElementById('cardsStatus');
    if (sch && !sch._bound){ sch._bound = true; sch.addEventListener('input', renderCardsList); }
    if (ss  && !ss._bound){  ss._bound  = true; ss.addEventListener('change', renderCardsList); }
    renderCardsList();
  };
}
	

(function(){
  const safe = (fn, d)=>{ try{ return fn(); }catch(_){ return d; } };
  const now  = ()=> Date.now();
  const uid  = ()=> Math.random().toString(36).slice(2,8).toUpperCase();

  // Petites aides, sans dépendre d’impl détail
  function svcSafe(){ return safe(()=>svc(), {}); }
  function curService(){
    return safe(()=>svc().service, '') ||
           safe(()=>document.getElementById('serviceKey')?.value, '');
  }
  function curWorkId(){
    return safe(()=>svc().work_id, '') ||
           safe(()=>document.getElementById('workIdHdr')?.textContent.trim(), '');
  }
  function curSession(){ return safe(()=>svc().__live?.session_id, null); }
  function curActor(){ return safe(()=>svc().__live?.role, 'operator'); }

  // Append-only
  function pushDecision(entry){
    const S = svcSafe();
    if (!Array.isArray(S.decisions)) S.decisions = [];
    S.decisions.push(entry);
    // cycle de persistance "habituel" si dispo
    safe(()=> typeof touch==='function' && touch());
    safe(()=> typeof renderDecisions==='function' && renderDecisions());
    // après rendu, on annote les lignes du journal (voir décorateur plus bas)
    setTimeout(decorateDecisionsList, 0);
  }

  // API centrale (n’écrase pas une éventuelle version existante)
  if (!window.logEvent){
    window.logEvent = function(action, {refs={}, info={}, snap={}}={}){
      const entry = {
        id: `E${new Date().toISOString().replace(/[-:TZ.]/g,'')}_${uid()}`,
        ts: now(),
        action: String(action||'').trim(),
        actor: curActor(),
        service: curService(),
        work_id: curWorkId(),
        session: curSession(),
        refs: (refs && typeof refs==='object') ? JSON.parse(JSON.stringify(refs)) : {},
        info: (info && typeof info==='object') ? JSON.parse(JSON.stringify(info)) : {},
        snap: (snap && typeof snap==='object') ? JSON.parse(JSON.stringify(snap)) : {}

      };
      pushDecision(entry);
    };
  }

  // Table “routes” (utilisé à l’ouverture depuis le journal)
  window.JOURNAL_ROUTES = window.JOURNAL_ROUTES || {
    config_loaded:        { view:'config' },
    workid_bound:         { view:'config' },
    charter_analyzed:     { view:'card',     pick:(e)=>({card_id:e.refs?.card_id}) },
    charter_saved:        { view:'charter' },
    card_exported:        { view:'card',     pick:(e)=>({card_id:e.refs?.card_id}) },
    card_deleted:         { view:'card',     pick:(e)=>({card_id:e.refs?.card_id}) },
    projector_opened:     { view:'card',     pick:(e)=>({card_id:e.refs?.card_id}) },
    projector_card_set:   { view:'card',     pick:(e)=>({card_id:e.refs?.card_id}) },
    scenario_created:     { view:'scenario', pick:(e)=>({sid:e.refs?.sid}) },
    scenario_promoted:    { view:'scenario', pick:(e)=>({sid:e.refs?.sid}) },
    scenario_deleted:     { view:'scenario', pick:(e)=>({sid:e.refs?.sid}) },
    session_started:      { view:'session' },
    session_paused:       { view:'session' },
    session_rotated:      { view:'session' },
    session_ended:        { view:'session' },
    proposal_validated:   { view:'card',     pick:(e)=>({card_id:e.refs?.card_id}) },
    proposal_pending:     { view:'card',     pick:(e)=>({card_id:e.refs?.card_id}) },
    proposal_rejected:    { view:'card',     pick:(e)=>({card_id:e.refs?.card_id}) },
  };

  // Décorateur : annote #decisions avec data-eid/action/sid/card (sans toucher au renderer)
  function decorateDecisionsList(){
    const cont = document.getElementById('decisions');
    if (!cont) return;
    const S = svcSafe();
    const arr = Array.isArray(S.decisions) ? S.decisions : [];
    const nodes = Array.from(cont.children).filter(n=>n.nodeType===1);
    // hypothèse par défaut : rendu anti-chronologique (dernier en haut)
    const order = window.__journalListOrder || 'desc'; // 'desc'|'asc'
    nodes.forEach((node, i)=>{
      // calcule l’index correspondant dans S.decisions
      const idx = (order==='desc') ? (arr.length - 1 - i) : i;
      const e = arr[idx];
      if (!e) return;
      if (!node.dataset.eid){
        node.dataset.eid = e.id;
        node.dataset.action = e.action || '';
        if (e.refs){
          if (e.refs.sid) node.dataset.sid = e.refs.sid;
          if (e.refs.card_id) node.dataset.card = e.refs.card_id;
        }
      }
    });
  }

  // Observer le conteneur du journal pour décorer à chaque re-render
  (function(){
    const cont = document.getElementById('decisions');
    if (!cont) return;
    const mo = new MutationObserver(()=>decorateDecisionsList());
    mo.observe(cont, {childList:true, subtree:false});
    // premier passage
    decorateDecisionsList();
  })();

  // Ouverture depuis journal (clic ligne → bonne vue)
  (function(){
    const cont = document.getElementById('decisions');
    if (!cont) return;
    cont.addEventListener('click', (e)=>{
      const row = e.target.closest('[data-eid]');
      if (!row) return;
      const eid = row.dataset.eid;
      const S = svcSafe();
      const ev = (S.decisions||[]).find(x=>x.id===eid);
      if (!ev) return;

      const route = (window.JOURNAL_ROUTES||{})[ev.action] || {};
      const args  = route.pick ? (route.pick(ev)||{}) : {};
      const v = route.view;

      if (v==='card' && args.card_id){
        showTab('cards');
        if (typeof renderCardDetail==='function') renderCardDetail(String(args.card_id));
        const pane = document.getElementById('journalDetail');
        if (pane){
          const it = (svc().items||[]).find(x=>String(x.id)===String(args.card_id));
          pane.textContent = it ? JSON.stringify(it, null, 2) : '—';
        }
      } else if (v==='scenario' && args.sid){
        showTab('scenarios');
        const sc = (svc().scenarios||[]).find(x=>String(x.id||x.sid)===String(args.sid));
        const pane = document.getElementById('journalDetail');
        if (pane) pane.textContent = sc ? JSON.stringify(sc, null, 2) : '—';
        // (si tu as une fonction dédiée pour ouvrir un scénario, tu peux l’appeler ici)
      } else if (v==='charter'){
        showTab('capture');
      } else if (v==='config'){
        showTab('reglages');
      } else if (v==='session'){
        showTab('projecteur');
      } else {
        // fallback : afficher l’entrée brute
        const pane = document.getElementById('journalDetail');
        if (pane) pane.textContent = JSON.stringify(ev, null, 2);
      }
    });
  })();
})();

//   ===================== JOURNAL — COLLECTEURS ==============================  
(function(){
  const safe = (fn,d)=>{ try{ return fn(); }catch(_){ return d; } };
  const SVC  = ()=> safe(()=>svc(), {});
  const lastItem = ()=> (SVC().items||[]).slice(-1)[0];

  // --- Réglages ---
  document.getElementById('btnLoad')?.addEventListener('click', ()=>
    setTimeout(()=> logEvent('config_loaded', { info:{source:'google'} }), 0)
  );
	
	// Remplace le collecteur existant
	document.getElementById('btnBindWork')?.addEventListener('click', ()=>
	  setTimeout(()=>{
	    const {client, service, date} = parseWorkId();
	    const wid = localStorage.getItem('paria_work_id') || '';
	    logEvent('workid_bound', { info:{ work_id: wid, client, service, date } });
	  }, 0)
	);

  // --- Charter ---
  document.getElementById('btnAnalyze')?.addEventListener('click', ()=>
    setTimeout(()=> {
      const it = lastItem();
      if (it?.id) logEvent('charter_analyzed', { refs:{card_id:String(it.id)}, snap:{title:it.title||it.reformulation||''} });
    }, 0)
  );
  document.getElementById('btnCharterToState')?.addEventListener('click', ()=>
	  setTimeout(()=>{
	    const c = JSON.parse(JSON.stringify((svc().charter || {})));
	    logEvent('charter_saved', { snap:{ charter: c }, snapLabel:'Charter' });
	  }, 0)
	);

  // --- Cards ---
  document.getElementById('btnOpenProjector')?.addEventListener('click', ()=>
    setTimeout(()=> {
      const cur = SVC().__projected_card || SVC().__last_card || lastItem();
      if (cur?.id) logEvent('projector_opened', { refs:{card_id:String(cur.id)} });
    }, 0)
  );
  document.getElementById('btnCardExportHtml')?.addEventListener('click', ()=>
    setTimeout(()=> {
      const id = safe(()=>document.querySelector('#cardView [data-card-id]')?.dataset.cardId, SVC().__last_card?.id);
      if (id) logEvent('card_exported', { refs:{card_id:String(id)}, info:{format:'html'} });
    }, 0)
  );
  document.getElementById('btnCardExportJson')?.addEventListener('click', ()=>
    setTimeout(()=> {
      const id = safe(()=>document.querySelector('#cardView [data-card-id]')?.dataset.cardId, SVC().__last_card?.id);
      if (id) logEvent('card_exported', { refs:{card_id:String(id)}, info:{format:'json'} });
    }, 0)
  );
  document.getElementById('btnCardExportMd')?.addEventListener('click', ()=>
    setTimeout(()=> {
      const id = safe(()=>document.querySelector('#cardView [data-card-id]')?.dataset.cardId, SVC().__last_card?.id);
      if (id) logEvent('card_exported', { refs:{card_id:String(id)}, info:{format:'md'} });
    }, 0)
  );
	document.getElementById('btnCardDel')?.addEventListener('click', ()=>
	  setTimeout(()=> {
	    const id = safe(()=>SVC().__last_card?.id);
	    if (id) logEvent('card_delete_clicked', { refs:{card_id:String(id)} });
	  }, 0)
	);

  // --- Scénarios (mutations : créations/suppressions via diff d’IDs) ---
	(function(){
	  const zone = document.getElementById('tab-scenarios');
	  if (!zone) return;
	
	  const getList = ()=> (svc().scenarios||[]).map(x=>({ id:String(x.id||x.sid), obj:x }));
	  let prev = getList();
	
	  zone.addEventListener('click', ()=>{
	    setTimeout(()=>{
	      const now = getList();
	      const prevMap = Object.fromEntries(prev.map(x=>[x.id, x.obj]));
	      const nowMap  = Object.fromEntries(now.map(x=>[x.id, x.obj]));
	
	      // créations: nouveau id => snapshot de l'objet créé
	      now.forEach(({id, obj})=>{
	        if (!prevMap[id]){
	          logEvent('scenario_created', {
	            refs:{ sid:id },
	            snap:{ scenario: JSON.parse(JSON.stringify(obj)) },
	            snapLabel: obj?.title || obj?.id || ''
	          });
	        }
	      });
	
	      // suppressions: id disparu => snapshot de l'objet avant suppression
	      prev.forEach(({id, obj})=>{
	        if (!nowMap[id]){
	          logEvent('scenario_deleted', {
	            refs:{ sid:id },
	            snap:{ scenario: JSON.parse(JSON.stringify(obj)) },
	            snapLabel: obj?.title || obj?.id || ''
	          });
	        }
	      });
	
	      prev = now;
	    }, 0);
	  });
	})();

  // --- Séance ---
  document.getElementById('btnStartSess')?.addEventListener('click', ()=> setTimeout(()=> logEvent('session_started', {}), 0));
	
	// Remplace seulement le collecteur pause
	document.getElementById('btnPauseSess')?.addEventListener('click', ()=> setTimeout(()=>{
	  logEvent('session_paused', { info:{ paused: !!(window.sess && window.sess.paused) } });
	}, 0));

  document.getElementById('btnRotateGuest')?.addEventListener('click', ()=> setTimeout(()=> logEvent('session_rotated', {}), 0));
  document.getElementById('btnEndSess')?.addEventListener('click', ()=> setTimeout(()=> logEvent('session_ended', {}), 0));

  // --- Décisions propositions (Valider / À préciser / Refuser) ---
  document.getElementById('tab-analyse')?.addEventListener('click', (e)=>{
    const b = e.target.closest('.decide'); if(!b) return;
    setTimeout(()=>{
      const last = lastItem();
      const pid  = (document.querySelector('[data-pid].active')?.dataset.pid) || null;
      const map  = { 'valide':'proposal_validated', 'a_preciser':'proposal_pending', 'refuse':'proposal_rejected' };
      const evt  = map[b.dataset.status] || 'proposal_pending';
      if (last?.id) logEvent(evt, { refs:{ card_id:String(last.id), prop_pid: pid } });
    }, 0);
  });

  // --- Projection (si un contrôle de “pin” expose l’ID) ---
  document.getElementById('projCard')?.addEventListener('click', (e)=>{
    const pin = e.target.closest('[data-pin-card-id]'); if(!pin) return;
    const cid = pin.dataset.pinCardId;
    setTimeout(()=> logEvent('projector_card_set', { refs:{ card_id:String(cid) } }), 0);
  });
})();

//   Journal: click -> affiche le contenu dans #journalDetail (sans changer d'onglet)  
(function(){
  const host = document.getElementById('decisions');
  if (!host || host.__bindDetail) return; 
  host.__bindDetail = true;

  host.addEventListener('click', function(ev){
    const row = ev.target.closest('[data-eid]');
    if (!row) return;

    // On refuse toute navigation/route héritée
    ev.preventDefault();
    ev.stopPropagation();
    ev.stopImmediatePropagation();

    const S    = (typeof svc==='function') ? svc() : {};
    const pane = document.getElementById('journalDetail'); 
    if (!pane) return;

    const eid  = row.dataset.eid;
    const act  = row.dataset.act || '';
    const sid  = row.dataset.sid || '';
    const cid  = row.dataset.card || '';
    const entry = (S.decisions||[]).find(x=>x.id===eid) || {};

    // 1) Charter: on affiche le JSON charter (snapshot si dispo)
    if (act === 'charter_saved'){
      pane.textContent = JSON.stringify(entry.snap?.charter || S.charter || {}, null, 2);
      return;
    }

    // 2) Scénarios: created/deleted -> on montre le snapshot conservé (si le scénario n’existe plus)
    if (act === 'scenario_created' || act === 'scenario_deleted'){
      const snap = entry.snap?.scenario;
      pane.textContent = JSON.stringify(snap || { id: sid }, null, 2);
      return;
    }

    // 3) Cards: deleted/exported/projector_set -> montre la card (snapshot si dispo)
    if (cid){
      const snap = entry.snap?.card;
      const it   = (S.items||[]).find(x=>String(x.id)===String(cid));
      pane.textContent = JSON.stringify(snap || it || { id: cid }, null, 2);
      return;
    }

    // fallback: l’entrée brute
    pane.textContent = JSON.stringify(entry, null, 2);
  }, true);
})();

//   Journal: clic sur "Restaurer" => affiche le snapshot dans #journalDetail (aucune navigation)  

//   Journal: clic sur "Restaurer" => exécute la restauration + confirme dans #journalDetail
(function(){
  const host = document.getElementById('decisions');
  if (!host || host.__bindRestore) return;
  host.__bindRestore = true;

  const SVC = ()=> (typeof svc==='function') ? svc() : {decisions:[]};

  function findEntryByRef(action, key, val){
    const S = SVC();
    return (S.decisions||[]).find(e => e.action===action && e.refs && String(e.refs[key])===String(val));
  }
  function findEntryById(eid){
    const S = SVC();
    return (S.decisions||[]).find(e => e.id===eid);
  }

  host.addEventListener('click', function(ev){
    const pane = document.getElementById('journalDetail'); 
    if (!pane) return;

    // Restaurer un scénario
    const bSc = ev.target.closest('.ev-restore-scenario');
    if (bSc){
      ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
      const sid  = bSc.dataset.sid;
      const ent  = findEntryByRef('scenario_deleted','sid',sid) || findEntryByRef('scenario_created','sid',sid);
      const ok   = (typeof restoreScenarioById==='function') ? restoreScenarioById(sid, ent?.snap) : false;
      pane.textContent = ok ? 'Scénario restauré ✔' : 'Restauration impossible.';
      return;
    }

    // Restaurer une card
    const bCd = ev.target.closest('.ev-restore-card');
    if (bCd){
      ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
      const cid  = bCd.dataset.cid;
      const ent  = findEntryByRef('card_deleted','card_id',cid);
      const ok   = (typeof restoreCardById==='function') ? restoreCardById(cid, ent?.snap) : false;
      pane.textContent = ok ? 'Card restaurée ✔' : 'Restauration impossible.';
      return;
    }

    // Restaurer le charter
    const bCh = ev.target.closest('.ev-restore-charter');
    if (bCh){
      ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation();
      const eid  = bCh.dataset.eid;
      const ent  = findEntryById(eid);
      const ok   = ent && typeof restoreCharter==='function' ? restoreCharter(ent.snap) : false;
      pane.textContent = ok ? 'Charter restauré ✔' : 'Restauration impossible.';
      return;
    }
  }, true);
})();
	
//   === RESTORES (append-only) ===  
function restoreScenarioById(sid, snap){
  const S = svc();
  if ((S.scenarios||[]).some(x=>String(x.id)===String(sid))) return true;
  const obj = snap?.scenario || { id: sid, title: sid, snapshot:{ items:[], decisions:[] } };
  (S.scenarios||(S.scenarios=[])).push(JSON.parse(JSON.stringify(obj)));
  touch();
  if (typeof renderScList==='function') renderScList();
  return true;
}

function restoreCardById(cid, snap){
  const S = svc();
  const ex = (S.items||[]).find(x=>String(x.id)===String(cid));

  // 1) Si la card existe déjà mais est "soft-deleted" → on enlève le flag
  if (ex){
    if (ex.deleted_ts || ex.deleted_at){
      delete ex.deleted_ts;
      delete ex.deleted_at;
      touch();
      if (typeof renderCardsTab==='function') renderCardsTab();
      if (typeof renderProjectorInline==='function') renderProjectorInline();
    }
    return true;
  }

  // 2) Sinon on réinjecte le snapshot
  const obj = snap?.card;
  if (!obj) return false;
  (S.items||(S.items=[])).push(JSON.parse(JSON.stringify(obj)));
  touch();
  if (typeof renderCardsTab==='function') renderCardsTab();
  if (typeof renderProjectorInline==='function') renderProjectorInline();
  return true;
}


function restoreCharter(snap){
  const S = svc();
  if (!snap?.charter) return false;
  S.charter = JSON.parse(JSON.stringify(snap.charter));
  touch();
  if (typeof hydrateCharter==='function') hydrateCharter();
  return true;
}

//   === SCENARIO ID MONOTONE ===  
function nextScenarioId(){
  const S = svc();
  S.meta = S.meta || {};
  const last = Number(S.meta.sc_counter || 0);
  const next = last + 1;
  S.meta.sc_counter = next;
  touch(); // persiste compteur
  return 'S'+next;
}


</script>

<div id="tab-cards" class="tab">
  <div class="row" style="display:flex; gap:16px; align-items:flex-start">
    <div class="card" style="flex:1; min-width:280px">
      <h4 style="margin-top:0">Cards</h4>
      <div style="display:flex; gap:8px; margin:6px 0">
        <input id="cardsSearch" type="text" placeholder="Recherche..." style="flex:1">
        <select id="cardsStatus">
          <option value="">Tous statuts</option>
          <option value="ok">Validé</option>
          <option value="maybe">À préciser</option>
          <option value="ko">Refusé</option>
        </select>
      </div>
      <div id="cardsList" style="max-height:calc(100vh - 320px);overflow:auto;border:1px solid #eee;border-radius:8px"></div>
    </div>
    <div class="card" style="flex:1.2; min-width:340px">
      <h4 style="margin-top:0">Détail</h4>
      <div id="cardView" style="min-height:120px">—</div>
      <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap">
        <button id="btnCardOpenProj">Ouvrir dans Projecteur</button>
        <button id="btnCardDel">Supprimer (soft)</button>
        <button id="btnCardExportMd">Exporter MD</button>
        <button id="btnCardExportHtml">Exporter HTML</button>
        <button id="btnCardExportJson">Exporter JSON</button>
      </div>
    </div>
    <div class="card" style="flex:1; min-width:320px">
      <h4 style="margin-top:0">JSON</h4>
      <pre id="cardJson" style="white-space:pre-wrap; min-height:260px; max-height:calc(100vh - 320px); overflow:auto">—</pre>
    </div>
  </div>
</div>

</body>
</html>














