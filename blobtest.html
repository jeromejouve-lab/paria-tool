<!doctype html>
<meta charset="utf-8" />
<title>PARIA ¬∑ Blob reader (isolation)</title>
<button id="run">Run blob test</button>
<pre id="log" style="white-space:pre-wrap;font:12px/1.4 ui-monospace,monospace"></pre>
<script>
const PROXY   = 'https://script.google.com/macros/s/AKfycbwioajzTAKB0xiseMUE75QMD_zDYrBALhOlKjoX3tNO-QS3WwsJPYYMLsZp4Ahnm2RWLg/exec'; // ‚Üê ton /exec
const SECRET  = 'Prox11_Secret';   // ‚Üê colle-le localement (ne commit pas)
const WORK_ID = 'test|rh|2025-10-02'; // ‚Üê ton work_id

const originExpected = location.origin; // ex: https://jeromejouve-lab.github.io
const $ = s => document.querySelector(s);
const log = (...a)=> { $('#log').textContent += a.join(' ')+'\n'; };

async function getJSON(u){
  const r = await fetch(u, { method:'GET' });
  // si CORS absent ‚Üí fetch l√®ve (TypeError), on catch plus bas
  const ct = r.headers.get('content-type')||'';
  if (!ct.includes('application/json')) throw new Error('not-json '+r.status);
  return r.json();
}

async function run(){
  $('#log').textContent='';
  log('Origin=', originExpected);

  // 1) DIAG (GET simple) ‚Äî doit marcher si CORS est ok c√¥t√© Apps Script
  const urlDiag = `${PROXY}?route=diag&secret=${encodeURIComponent(SECRET)}`;
  log('\n[1] GET diag ‚Üí', urlDiag);
  let diag;
  try {
    diag = await getJSON(urlDiag);
    log('diag:', JSON.stringify(diag));
    if (!diag.ok) throw new Error('diag not ok');
  } catch(e){
    log('‚ùå DIAG failed:', e.message, '\n‚Üí PROBL√àME CORS (header Access-Control-Allow-Origin manquant) ou URL /exec invalide.');
    return;
  }

  // 2) √âTAT (GET git_find) ‚Äî c‚Äôest ici que ‚Äútabs.projector‚Äù doit sortir
  const urlFind = `${PROXY}?route=git_find&work_id=${encodeURIComponent(WORK_ID)}&secret=${encodeURIComponent(SECRET)}`;
  log('\n[2] GET git_find ‚Üí', urlFind);
  let found;
  try{
    found = await getJSON(urlFind);
    log('git_find:', JSON.stringify(found));
  } catch(e){
    log('‚ùå git_find failed:', e.message, '\n‚Üí CORS/URL/secret. Si diag passe mais pas git_find, route non expos√©e c√¥t√© GAS.');
    return;
  }

  // lecture de l‚Äô√©tat (si pr√©sent)
  const tabs = found?.state?.tabs;
  if (tabs) {
    log('‚úÖ tabs =', JSON.stringify(tabs));
  } else {
    log('‚ö†Ô∏è  tabs ABSENT dans le state ‚Üí la remote restera en Pause.\n   Cause probable: aucun snapshot d‚Äô√©tat publi√© (git_snapshot) pour ce WORK_ID.');
  }

  // 3) SNAPSHOT (GET git_load via json_path renvoy√©)
  const path = found?.snapshot?.json_path || found?.json_path;
  if (!path) {
    log('\n[3] snapshot: pas de json_path dans git_find ‚Üí rien √† charger (ou pas encore publi√©).');
    return;
  }
  const urlLoad = `${PROXY}?route=git_load&json_path=${encodeURIComponent(path)}&secret=${encodeURIComponent(SECRET)}`;
  log('\n[3] GET git_load ‚Üí', urlLoad);
  try{
    const snap = await getJSON(urlLoad);
    log('snapshot keys:', Object.keys(snap));
    log('‚úÖ snapshot OK (m√™me si chiffr√©, on a le contenu).');
  } catch(e){
    log('‚ùå git_load failed:', e.message, '\n‚Üí path invalide ou CORS.');
  }

  // verdict
  if (tabs && tabs.projector === 'on') {
    log('\n‚úÖ VERDICT: chemin + autorisation OK pour l‚Äô√©tat. Une remote devrait sortir de Pause.');
  } else {
    log('\nüö© VERDICT: snapshot lisible mais √©tat absent ‚Üí publier l‚Äô√©tat via POST git_snapshot (tabs.projector:"on").');
  }
}

$('#run').addEventListener('click', run);
</script>
